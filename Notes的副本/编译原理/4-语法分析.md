## Content

[toc]

# ※语法分析

![image-20230308100017140](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230308100017140.png)

## 简介

由语法分析程序完成

**依据**：源语言的语法规则

**任务**：

1. 从源程序记号序列中识别出各类语法成分
2. 进行语法检查

**输出**：分析树（唯一输出）

![shadow-image-20230308101013582](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230308101013582.png)

没有与符号表进行交互！！！

不应明显影响编译程序对正确程序的处理效率

**错误恢复策略**：

- ==紧急恢复==：发现错误时，分析程序每次抛弃一个输入记号，直到扫描的记号属于某个指定的同步记号集合为止（通常是定界符）
- 短语级回复
- 出错产生式
- 全局纠正

## 自顶向下分析方法



### 递归下降分析

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230308104207148.png" alt="shadow-image-20230308104207148" style="zoom:50%;" />



**实现**：

- 文法的每个非终结符对应一个递归过程
- 每个过程作为一个不贰过车工，一旦发现某个产生式与输入串匹配，则用该产生式展开分析树，并返回 true；否则分析树不变，返回 false

**存在的问题**：

1. 左递归文法可能导致陷入死循环
2. 回溯
3. 工作的重复
4. 效率低，代价高（需要试探）

==理论上的，极少使用的==



### 递归调用预测分析

确定的、不带回溯的递归下降分析方法

 #### 克服回溯

根据所面临的输入符号准确的指派一个候选式去执行任务

该选择的工作结果是确信无疑的

#### 对文法的要求

1. 不含左递归
2. $\operatorname{FIRST}\left(\alpha_i\right) \cap \operatorname{FIRST}\left(\alpha_j\right)=\phi \quad(i \neq j)$
   - ![image-20230308110749761](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230308110749761.png)
   - A 的所有候选式的开头终结符号集两两互不相交

![shadow-image-20230308111657559](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230308111657559.png)

#### 程序构造

1. 预测分析程序的转换图
2. 转换图的工作过程
3. 转换图的化简
4. 预测分析程序的实现

##### **转换图**

1. 每个非终结符号有一张图
2. 边的标记可以是终结符号也可以是非终结符号
3. 在 A 上的转移意味着相应 A的过程的调用
4. 在终结符 a 上的转移，意味着下一个输入符号若为 a，做此转移

###### **从文法构造转化图**

1. 重写文法
   1. 消除左递归
   2. 提取左公因子
2. 对每一个非终结符 A
   1. 创建一个初始状态和一个中介状态
   2. 对每一个产生式，创建一条从初态到终态的路径

**消除左递归**

![shadow-image-20230308112341799](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230308112341799.png)

输入：无环路、无空产生式

**消除空产生式**

![image-20230308114303862](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230308114303862.png)

**提取左公因子**

![shadow-image-20230308114628783](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230308114628783.png)

##### 工作过程



##### 化简



##### 程序实现

 

### 非递归预测分析

使用一张分析表和一个栈联合控制



#### 模型及工作过程

![shadow-image-20230315100041967](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230315100041967.png)

- 输入缓冲区：存放被分析的输入符号串，结尾为$

- 符号栈：存放一系列文法符号，\$存与栈底。分析开始时，将$入栈以标识栈底，然后再将文法的开始符号入栈
- 分析表：二维数组，根据给定的 A 和 a，在分析表 M 中找到被调用的产生式
- 输出流；分析过程中不断产生的产生式序列
- ==预测分析控制程序==：根据栈顶符号 X 和当前输入符号 a，分析有 4 种可能动作
  1. X=a=$，宣告分析成功，停止分析
  2. X=a≠$，从栈顶弹出 X，输入指针前移一个位置
  3. X 为终结符但不等于 a，报告发现错误
  4. X 为非终结符，访问分析表 M
     1. 右部符号不为空，先将 X 弹出，然后吧产生式的右部符号串反序推入栈中
     2. 右部位空，弹出 X
     3. error，调用错误处理程序

```pseudocode
输入：输入符号串，文法G的一张预测分析表M。
输出：若在L(G)中，则输出的最左推导，否则报告错误。
方法：分析开始时，$在栈底，文法开始符号S在栈顶，$在输入缓冲区中 
	置ip指向 $ 的第一个符号；
	do {
			令X是栈顶符号，a是ip所指向的符号； 
			if (X是终结符号或$)  {
				if (X==a)  {
					从栈顶弹出X; ip前移一个位置; 
				};
				else  error();
			else  /* X是非终结符号 */ 
			if (M[X, a]=XY1Y2…Yk ) {
				从栈顶弹出X;
				把Yk、Yk-1、…、Y2、Y1压入栈，Y1在栈顶; 
				输出产生式XY1Y2…Yk ;
			};
			else  error();
} while(X!=$)  /* 栈不空，继续 */
```



#### 预测分析表的构造

1. 改写文法
2. 构造 FIRST 集合
3. 构造 FOLLOW 集合
4. 构造预测分析表



FIRST 集合

![image-20230320220146892](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230320220146892.png)

FOLLOW 集合

![image-20230320220201532](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230320220201532.png)

构造预测分析表

```pseudocode
输入：文法G
输出：文法G的预测分析表M 
方法：
	for (文法G的每个产生式 A  ) { 
		for (每个终结符号 aFIRST())
			把 A  放入 M[A, a] 中; 
		if (FIRST())
			for (任何 bFOLLOW(A)) 
				把 A  放入 M[A, b] 中;
			}；
for (所有无定义的M[A, a]) 标上错误标志
```

![image-20230320221554996](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230320221554996.png)

![image-20230315110147241](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230315110147241.png)

![shadow-image-20230315110728712](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230315110728712.png)

易错：

- 画表的时候要有$符

#### LL（1）文法

如果一个文法的预测分析表不含多重定义的表项，则称为 LL(1)文法

1. 第一个 L 表示从左至右扫描输入符号串
2. 第二个 L 表示生成输入串的一个最左推导
3. 1 表示在决定分析程序的每步动作时，向前看一个符号

##### 判断方法

1. 产生式判断：每一个产生式都满足![shadow-image-20230315111655137](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230315111655137.png)
2. 分析表判断

#### 错误处理示例

1. 栈顶是终结符号，但是和字符不匹配
2. 栈顶是非终结符，但是预测分析表为空

处理方法：

1. 弹出栈顶终结符号
2. 跳过剩余输入符号串中的若干符号，直到可以继续分析为止

##### 带有同步化信息的分析表

![shadow-image-20230315115023648](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230315115023648.png)

## 自底向上分析方法

- 输入串的扫描：自左向右
- 分析树的构造：自底向上
- 分析过程：
  - 从输入符号串开始分析
  - 查找当前句型的“可规约串”
  - 使用规则，把它规约成相应的非终结符号
  - 重复
- ==关键：找出“可规约串”==
- 常用方法：
  - *优先分析方法
  - LR 分析方法

### “移进-归约”分析方法

- 优先法：通过符号间的优先关系来确定句柄
  - 简单优先
  - 算符优先法：只适用于算符优先文法
    - 算符文法：不存在具有相邻非终结符的产生式（只存在运算对象和运算符相邻而不存在运算对象与运算对象相邻）
    - 算符优先文法：任意两个算符（终结符）在同一方向上只存在一种优先关系
- 状态法：用 DFA 进行语法分析



#### 分析过程

1. 把输入符号一个个地==移进==栈中
2. 当栈顶的符号性成果某个产生式的一个候选式时，在一定条件下，把该符号串替换（即==归约==）为该产生式的左部符号
3. 重复 2，直到栈顶符号不再是可规约串为止
4. 重复 1-3，直到最终归约出文法开始符号 S

#### 项目

产生式加上一个点，这个点代表了当前识别的程度

A->.BC 代表还没有读取任何符号

A->BC. 代表已经读取完，可以进行归约了

### LR 分析方法

- 符号栈：存储当前分析过的单词
  - 栈中的符号串是当前句型的活前缀之一
  - ==活前缀==：不含相应句型的句柄右部的任何符号的前缀
- 状态栈：记录当前状态
- 分析表：记录状态与待读符号决定的动作
  - Action表：Action[S,a]=m 表示对当前状态 S（状态栈栈顶），当前输入符号为a 时进行的语法动作m，m 包含
    - shift x：把当前符号和状态 S 移进栈。
    - reduce x：使用 x 产生式进行归约。A->β，从栈顶弹出β的长度 r 项，当前栈顶状态为$S_{m-r}$然后将文法符号 A 和状态 S 入栈，$S=goto[S_{m-r},A]$
    - acc：分析成功
    - err：出错
  - Goto表
- 缓冲区：保存待读符号
- 控制程序



![shadow-image-20230403192918861](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230403192918861.png)

在不同的 LR 分析法中，除了分析表的构建不同，其他步骤都是相同的。

#### LR(0) 分析法

0 意味着不需要超前搜索符号

可归约时一定要归约

##### LR(0) 项目

由数个项目组成的集合称为项目集，项目集便是 DFA 中的状态

DFA 中所有状态的集合称为项目集规范簇

##### 项目集闭包

求解 项目集 C 的闭包

1. 遍历 C 中的项目，若存在形似$S->\alpha .A\beta$的项目，如果 A 是非终结符，找到所有左部是 A 的产生式$A->\alpha\beta$，将$A->.\alpha\beta$加入 C 中
2. 重复步骤 1，直到 C 的规模不在变大

##### 状态转移函数GO(C,X)

1. 遍历 C 中所有项目，如果存在形似$S->\alpha.X\beta$的项目，将$S->\alpha X.\beta$加入集合 C'
2. C'的闭包便是状态 C 读取 X 后转换成的新状态

##### 拓广文法

> 得到一个 DFA 的必要条件是确定一个初始状态和已知获取新状态的方法，此时我们已经满足了后者，现在只要确定 DFA 的初始状态即可得到 DFA
>
> 为了使文法有唯一出口，引入拓广文法

添加新的开始符号 S'，将 S'->S 加入产生式集合

初始状态 I0 便是项目 S'->.S 的闭包



##### 构建分析表

1. 终结符放在 Action 表头（加上$），非终结符放在 goto 表头，假设项目集规范簇有 N 个状态，创建 N 行

2. 对每一个状态 $I_x$，

   - 若存在$I_y=GO(I_x,T)$，其中 T 是终结符，则 Action\[x][T]=sy，

   - 若存在$I_y=GO(I_x,V)$，其中 V 是非终结符，则 Action\[x][V]=y

   - 若存在$S'->S$，则 action\[x][$]=acc

   - 若存在$A->\alpha\beta.$，即点在最右边，对任意终结符 T，Action\[x][T]=rk，其中 k 是产生式$A->\alpha\beta$的编号

3. 表中空着的单元是 err



#### SLR(1)分析法



# 待完成

