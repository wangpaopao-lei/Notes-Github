# C 语言词法分析程序实验报告



<center>
  姓名：王磊
</center>

<center>
  学号：2020211538
</center>

<center>
  提交日期：2023-3-27
</center>



## Content

[toc]

<div STYLE="page-break-after: always;"></div>

## 需求分析

### 开发环境

本程序在 MacOS 系统上开发，使用 C++语言编写，使用 Clang 编译器编译。

程序可在各平台下编译运行

### 功能及数据说明

本程序用于 C 语言代码的词法分析, 程序会读取代码文件, 对其进行词法分析, 并输出符号流, 以配合后续的语法分析/语义分析等。如遇到错误，会进行错误位置提示，以及后续的错误恢复。

程序的输入数据为 C 语言代码源代码文件，输出为记号流，包含符号位置、类别、原始值，以及整体统计信息。

### 数据流

程序从标准输出中读取代码，将识别到的符号打印到标准输出中，可以通过命令行参数将输出重定向至指定文件中。

本程序的数据流见下图

![shadow-未命名](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D.png)<div STYLE="page-break-after: always;"></div>*

## 总体设计

### 文件结构

```shell
├── main.cpp
├── main.h
├── parser.cpp
├── parser.h
├── result
│   ├── a3.out
│   └── err.out
└── test
    ├── a.c
    └── err.c
```

- main.cpp：主程序函数
- main.h：主函数头文件
- parser.cpp：词法分析器源文件
- parser.h：词法分析器头文件
- result：存放结果文件
  - A3.out：a.c 文件对应的词法分析结果
  - err.out：err 文件对应的词法分析结果
- test：存放测试文件
  - a.c：无错误的 c 语言测试文件
  - err.c：包含一些错误的测试文件

### 数据结构设计

```C++
/*
 * @name:Word
 * @attr1:sign(单词类型）
 * @attr2:attr_num(整型的值）
 * @attr3:attr_gif(浮点型的值）
 * @attr4:attr_str(字符串的值）
 * @description:表示单词的类别和原始值
 */
class Word {
public:
    WordClass sign = WordClass::empty;
    long long attr_num = 0;
    double attr_gif = 0;
    string attr_str;
};
```

本程序最重要的数据结构为 Word 类，在 Word 类中定义了一个单词的类型、原始值。其中类型变量 sign 是一个 WordClass 枚举类。

### 功能模块划分

- 词法分析器模块 Parser：提供 parse_file() 功能函数，该函数从ostringstream 流中读取代码，输出结果到标准输出流并计算统计信息。
- 主程序模块 main：从命令行读取参数，打印命令行消息，调用词法分析函数完成分析，并将结果输出到用户指定位置（默认为命令行）

<div STYLE="page-break-after: always;"></div>

## 详细设计

### 有限状态自动机

在词法分析函数中，程序将逐行读取前面传入的数据，并依据下图所示的词法分析 DFA 进行相应的状态转换。

![shadow-扫描全能王 2023-03-27 21.05_1](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/%E6%89%AB%E6%8F%8F%E5%85%A8%E8%83%BD%E7%8E%8B%202023-03-27%2021.05_1.jpg)

### 回退函数 retract

在读取操作符的时候会需要程序进行超前扫描，通过超前扫描的结果判断出操作符的值后，使用 retract 函数进行回退，以保证不会漏掉字符。由于前面用两个 int 变量保存了当前读取的行和列坐标，该操作变得异常容易。

```C++
void parser::retract() {
    file.seekg(-1, ios_base::cur);
    char temp;
    temp = file.get();
    if (temp == '\n') {
        row_count--;
    }
    file.seekg(-1, ios_base::cur);
}
```

### 关键字辨别函数 reserve

在读取到不被双引号分割的字符串后，需要判断该标识符是用户自定义标识符还是系统关键字。前面已经创建了关键字的枚举类，在这个函数中，我列出了关键字表，依据比对结果将标识符赋值为枚举类中的某个值，若不是关键字，则赋值为 `KeywordClass::is_not_kw`，表示该标识符非关键字。

```C++
KeywordClass parser::reserve() {
    string kwTable[] = {"auto", "double", "int", "struct", "break",
                        "else", "long", "switch", "case", "enum", "register", "typedef",
                        "char", "extern", "return", "union", "const", "float", "short",
                        "unsigned", "continue", "for", "signed", "void", "default", "goto",
                        "sizeof", "volatile", "do", "while", "static", "if", "inline", "restrict",
                        "_Alignas", "_alignof", "_Atomic", "_Bool", "_Complex", "_Generic",
                        "_Imaginary", "_Noreturn", "_Static_assert", "_Therad_local"};
    for (int i = 0; i < 44; i++) {
        if (strcmp(token, kwTable[i].c_str()) == 0) {
            return (KeywordClass) i;
        }
    }
    return KeywordClass::is_not_kw;
}
```

### 单词输出函数 return_id

在 DFA识别出单词并返回初始状态之后，需要对读取到的单词进行输出，该输出包含类型、原始值、位置三个属性。在这里，我将 return_id 函数进行了四次重载，以适应对不同单词的输出。

此处只展示函数声明

![shadow-image-20230327212107066](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230327212107066.png)

### 错误检测及恢复模块

在程序的每个阶段，我都设计了转移到 error_state 的过程，在错误处理语句中，程序会输出错误所在的位置，并暂时跳过错误单词。

```C++
case DFAStates::error_state:
                parser::out << "error state" << endl << (int) C << endl << token << endl;
                state = DFAStates::begin;
                error_count++;
                break;
```

<div STYLE="page-break-after: always;"></div>

## 程序测试

### 测试环境

本程序在 MacOS 系统下， 使用 Clang17 编译器进行编译运行。经过测试，本程序自身的源代码可通过词法分析检测，但由于篇幅限制，在这里只给出两个简单的测试用例。第一个测试用例用于测试程序在正确情况下的运行情况；第二个测试用例用于测试程序的错误提示与错误恢复能力。

### 测试功能

- 测试用例 1

```C
//test
/* test
 * test
 */
#define TEST

long foo(short a) {
	return a + 123434;
}

int main() {
	const float asd = 123.20312;
	static char *assdsad = "asdsadasdsadsad";
	char ch = '\n';
	if (1) {} else {}
	switch(1) {case '1': default:;}
	for (;;) {break;}
	while(0) {continue;}
	int a = sizeof(double);
	struct asd;
	union c;
	return 0;
}
```

- 测试用例 2

```C
123.23
123.
0x123.213
0b00110
0b123
0x23213g
12321abc
"unterminated
'u
"newline with backslash\
newline"
@@@
/* unfinished block comment

```

### 预期结果

针对正确的代码能够输出每一个符号的类型、位置及原始值，最后输出文件行数、字数、以及各类型符号单词的统计。

针对有词法错误的代码能够报告错误的位置，在最后报告错误数量。

### 测试结果

只展示部分，完整结果在文件中给出。

![shadow-image-20230327214049702](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230327214049702.png)

![shadow-image-20230327214112011](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230327214112011.png)

![shadow-image-20230327214138011](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230327214138011.png)
