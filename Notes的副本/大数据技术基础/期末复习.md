# 目录

[toc]





## CH1 概述

----

### 4V特点

1. volume：量大
2. velocity：速度快（生产到消耗，决策时间很短）
3. variety：多样化（非结构化数据）
4. value：价值密度低，商业价值高

### 产生阶段

1. 运营式系统：数据伴随运营活动产生（被动产生）
2. 用户原创内容：主动产生
3. 感知式系统

### 科学研究四范式

1. 实验：描述现象
2. 理论：使用模型进行泛化
3. 计算：复杂线性
4. 数据探索

### 计算模式

1. 批处理：大规模数据的批量处理
2. 流计算：连续到达数据
3. 图计算
4. 查询分析计算：大规模数据的存储管理、查询分析，需要实时或准时

### 技术框架

1. 收集
   - sqoop，canal，关系型数据
   - flume，流式数据
   - kafka，分布式消息队列
2. 存储
   - HDFS，分布式文件系统
   - HBASE，分布式数据库
   - Kudu，分布式列式存储数据库
3. 资源管理和服务协调
   - Zookeeper，服务协调
   - YARN，资源管理
4. 计算引擎
   - MapReduce，批处理
   - SPARK，通用 DAG 引擎
   - Storm，Spark Streaming，流式计算
5. 数据分析
   - Hive，基于 MapReduce 的 SQL 引擎
   - MLib，基于 Spark的机器学习库

### 多路合并，多路复用

常见的 Flume 拓扑架构

![image-20221227121014418](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20221227121014418.png)

![image-20221227121023727](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20221227121023727.png)







## CH2 Kafka分布式消息队列

---

### Kafka 设计动机

1. 生产者消费者耦合度高（彼此依赖）
2. 生产者消费者处理速度不对等
3. 大量并发连接对消费者不友好

### 基本架构

push-pull优势

1. 消费者按需获取，避免较大压力
2. offset 由消费者自己维护，使得 broker 轻量化

### 负载均衡

对 leader partition 的负载均衡

原因：只有 leader partition 负责对外读写







## CH3 HDFS，NoSQL

### 文件存储格式区别

|          | 行式存储                                                 | 列式存储                           |
| -------- | -------------------------------------------------------- | ---------------------------------- |
| 写       | 一次完成                                                 | 拆分到各列，效率低                 |
| 读       | 读取几列数据时需要大范围读，效率低了；读取整行数据效率高 | 读取几列数据效率高，反之           |
| 数据压缩 | 不方便                                                   | 相同类型的数据存储在一起，便于压缩 |

### 扩展

- 纵向扩展：增加单个节点性能
- 横向扩展：增加节点数量，不会受到物理条件的制约

### HDFS 架构

1. NameNode：集群管理者，管理元信息和 DataNode
   + 元信息：目录树，文件数据块信息
   + DataNode：维护心跳，损坏时重构丢失的数据块
2. DataNode：实际存储数据块
3. Client：与 NN、DN 进行交互，实现文件分块
4. Zookeeper：选举 NameNode

### 容错性设计

1. NN 故障：启用 Secondary NameNode
2. DN 故障：NN 通过其他 DN 上保存的副本重构
3. 数据快损坏：校验码

### NoSQL 三大理论基石

#### CAP理论

C：consistency 一致性

Availability可用性

Partition 分区容错性

==**NoSQL无法同时满足这三个特点，最多满足两个**==

#### BASE理论

BA：基本可用，允许分区失败

S：软状态，数据可以有一段时间不同步

E：最终一致性，***可以暂时读不到更新后的数据，但一段时间后必须读到***

==NoSQL 需要满足 BASE==

#### 最终一致性

1. 强一致性：W+R>N（*读和写加起来比备份数多，说明一定会读到写过的备份<鸽巢原理>*），更新后的数据都能被读到
2. 弱一致性，W+R<=N，更新后的全部或部分读不到







## CH4 HBase分布式结构化存储

---

### 数据模型

1. physical：列簇式存储，列簇单独存储，列簇内数据按行存储
2. logical：
   - 表由一系列行构成
   - rowkey ，标识行，作为“主键”
   - column family，每行数据有相同的 column family，访问控制的基本单位
   - column qualifier，family 内列的标识
   - cell：通过 rowkey、family、qualifier 唯一定位一个 cell，cell 内部保存多个版本数据

### RegionServer组件

1. BlockCache：读缓存
2. MemStore：写缓存
3. WAL：write ahead log（在磁盘上）

#### 写过程

1. 写入 MemStore，写信息写入 WAL
2. 通知用户写入成功（实际上还没成功）
3. 宕机，此时数据丢失
4. 开机后，通过WAL 恢复





## CH5 ZooKeeper、YARN资源管理和服务协调

---

### ZooKeeper 有奇数个节点？

ZooKeeper 使用 ZAB 协议（多个节点写入时，写入多数节点才算成功），如果为偶数个节点，写入一半时不算成功，因此采用奇数个节点可以节省节点

### YARN产生背景

MapReduce v1 的局限性

1. master/slave 架构可靠性差
2. Jobtracker 兼顾了资源管理、作业控制两个功能，导致扩展性变差
3. MapReduce v1 基于槽位进行资源分配，导致资源利用率低

### YARN 工作流程

1. Client 向ResourceManager 提交应用程序
2. RM 为该应用分配 Container，与对应的 Node Manager 通信，让 NM 启动 ApplicationMaster，之后 AM 的生命周期被 RM 管理
3. AM 启动后向 RM 注册，用户此时可通过 RM 查看任务状态，初始化应用，按策略分配资源
4. AM 轮询向 RM 申请资源
5. 申请到资源，启动 Container（通过 NM）
6. NM 为任务设置运行环境，启动脚本
7. AM 通过两种方式获取 Container 运行状态
   1. AM 与 RM 维护心跳
   2. Container 通过 RPC 协议向 AM 汇报

### 三种资源调度架构

1. 中央式
2. 双层
3. 共享







## CH6 计算引擎

----

### MapReduce 五个组件

1. InputFormat：输入组件，将数据拆分为 key-value
2. Mapper：将 key-value 映射成另一组 key-value
3. Partitioner：依据 key 对数据进行分组
4. Reducer：以组为单位进行 reduce 规约
5. OutputFormat：将最终产生的 key-value 输出

**可选：**

combiner：放在 Mapper 之后，用于做局部聚集

### MapReduce 工作流程



### MapReduce 关键技术

1. 数据本地化：将 map task 调度到处理数据所在节点上
2. 推测执行：预测那些“拖后腿”任务，进行备份，选择最快执行出结果的那个

### SPARK RDD

弹性分布式数据集

RDD 上有两类操作（算子）

1. transformation：RDD[x] -> RDD[Y]
2. Action: RDD[X] -> Z

### SPARK 生命周期

1. 生成逻辑计划
2. 生成物理计划
3. 调度并执行




## CH7 流式计算引擎

----

### 分类

1. 基于行，Storm，单条数据延迟低
2. 基于微批处理，Spark Streaming，吞吐率高

### Storm 可靠性实现

基于 Acker 框架追踪消息

1. 为每个 tuple 保存 64 位校验值，初始值为 0
2. 每当 bolt 发送或接受一个 tuple，tuple 的 ID 与这个校验值进行异或操作
3. 如果每个 tuple 都处理完了，则校验值变为 0

### Flink 的窗口

1. session 会话窗口，基于时间定义，终止标志就是隔一段时间没有数据来
2. tumbling 滚动窗口，基于时间或计数，窗口之间不重合
3. sliding 滑动窗口，基于时间或计数，定义窗口大小和滑动步长







