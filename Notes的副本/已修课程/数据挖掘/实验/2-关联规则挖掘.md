# 3.9解答





<center>
  课程——并行计算与 GPU 编程
</center>


<center>
  班级——202011321


<center>
  学号——2020211538
</center>


<center>
  姓名——王磊
</center>

---



## FP 树

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/39DCAFB84AFDA06AE57D94029E634E58.png" alt="shadow-39DCAFB84AFDA06AE57D94029E634E58" style="zoom:50%;" />

## 3.9.a

### Apriori算法

1. 第一次扫描，得到 C1

| Itemset |  sup  |
| :-----: | :---: |
|    M    |   3   |
|    O    |   3   |
|  **N**  | **2** |
|    K    |   5   |
|    E    |   4   |
|    Y    |   3   |
|  **A**  | **1** |
|  **U**  | **1** |
|  **C**  | **2** |
|  **I**  | **1** |
|  **D**  | **1** |

2. 删除不满足的元素，得到L1

| Itemset | sup  |
| :-----: | :--: |
|    M    |  3   |
|    O    |  3   |
|    K    |  5   |
|    E    |  4   |
|    Y    |  3   |

3. 自连接得到 C2

| Itemset |
| :-----: |
|   MO    |
|   MK    |
|   ME    |
|   MY    |
|   OK    |
|   OE    |
|   OY    |
|   KE    |
|   KY    |
|   EY    |

4. 第二次扫描统计 sup，得到C2

| Itemset |  sup  |
| :-----: | :---: |
| **MO**  | **1** |
|   MK    |   3   |
| **ME**  | **2** |
| **MY**  | **2** |
|   OK    |   3   |
|   OE    |   3   |
| **OY**  | **2** |
|   KE    |   4   |
|   KY    |   3   |
| **EY**  | **2** |

5. 删除不满足的项，得到 L2

| Itemset | sup  |
| :-----: | :--: |
|   MK    |  3   |
|   OK    |  3   |
|   OE    |  3   |
|   KE    |  4   |
|   KY    |  3   |

6. 自连接得到 C3

| Itemset |
| :-----: |
|   MKO   |
|   MKE   |
|   MKY   |
|   OKE   |
|   OKY   |

7. 扫描得到 C3

| Itemset | sup  |
| :-----: | :--: |
|   MKO   |  1   |
|   MKE   |  2   |
|   MKY   |  2   |
|   OKE   |  3   |
|   OKY   |  2   |

8. 得到 L3

| Itemset | sup  |
| :-----: | :--: |
|   OKE   |  3   |

9. 最终得到的频繁项集为  \{OKE, MK, OK, OE, KE, KY}

### FPGrowth算法

1. 统计每个元素的 frequency

| Item  | frequency |
| :---: | :-------: |
|   M   |     3     |
|   O   |     3     |
| **N** |   **2**   |
|   K   |     5     |
|   E   |     4     |
|   Y   |     3     |
| **A** |   **1**   |
| **U** |   **1**   |
| **C** |   **2**   |
| **I** |   **1**   |
| **D** |   **1**   |

2. 得到 header table

| Item | frequency |
| :--: | :-------: |
|  K   |     5     |
|  E   |     4     |
|  M   |     3     |
|  O   |     3     |
|  Y   |     3     |

3. 修改原事务表，得到新的频繁事务

| TID  |   Items   |
| :--: | :-------: |
| T100 | K E M O Y |
| T200 |  K E O Y  |
| T300 |   K E M   |
| T400 |   K M Y   |
| T500 |   K E O   |

4.  构建初始 FP 树

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/39DCAFB84AFDA06AE57D94029E634E58.png" alt="shadow-39DCAFB84AFDA06AE57D94029E634E58" style="zoom:50%;" />



5. 求条件模式基

| Item | conditional patern base |
| :--: | :---------------------: |
|  Y   | {KEMO:1},{KEO:1},{KM:1} |
|  O   |     {KEM:1},{KE:2}      |
|  M   |      {KE:2},{K:1}       |
|  E   |          {K:4}          |

6. 统计条件模式基中元素的频次，去除不满足最小支持度的

| Item | conditional patern base |
| :--: | :---------------------: |
|  Y   |           K:3           |
|  O   |          KE:3           |
|  M   |           K:3           |
|  E   |           K:4           |

7. 由此构建 FP 子树，由于该题中各项的子树都为单路径树，此处不作展示

8. 求得频繁项集   \{KY, KO, EO, KEO, MK, KE}

### 简要分析

1. FPGrowth 算法只对数据库进行了两次扫描；相比之下 Apriori 算法在每次计算 Lk 的时候都要进行扫描
2. 随着算法的深入，Apriori 算法的复杂度逐渐升高；而 FPGrowth 算法由于使用了分治的思想，后续仅对子问题进行分析，复杂度会降低

## 3.9.b

Min_conf = 80%

1. 由前文得到的频繁项集挖掘强关联规则

| Itemset | sup  |
| :-----: | :--: |
|   OKE   |  3   |

2. 由 L3 出发，分别计算置信度

|    Rules     | Condifence |
| :----------: | :--------: |
| =={O,K}->E== |  3/3=100%  |
| =={O,E}->K== |  3/3=100%  |
|   {K,E}->O   |  3/4=75%   |

3. 最终得到的强关联规则为

|  Rules   | Support | Condifence |
| :------: | :-----: | :--------: |
| {O,K}->E |   60%   |  3/3=100%  |
| {O,E}->K |   60%   |  3/3=100%  |