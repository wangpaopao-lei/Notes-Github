##  contents

[toc]

# 键值数据库

![shadow-image-20230410080223219](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230410080223219.png)

## 概述

1. value 可以是任何内容
2. 一般采用驻留内存的数据存储方式保障高性能访问

### Redis

1. 可基于内存也可持久化
2. 高度可分区，相比于其他数据库更容易实现更大规模的水平扩展

### 特点

1. 高性能：key 和 value 通过哈希算法关联起来，以达到快速查询的目的
2. 操作简单：提供丰富的 API 支持对不同类型键值的操作
3. 支持多种数据结构类型
4. 支持 key 过期（TTL）等管理特性
5. 支持持久化操作
6. 支持事务管理：Redis 所有操作都是原子性的
7. 可扩展性：分片技术
8. 高可用性：主从集群复制机制，可以进行实时数据的复制

## 键值数据存储逻辑架构

键值操作主要有三类：

1. set（key，value）
2. get（key）
3. del（key）



![shadow-image-20230410083419447](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230410083419447.png)

### Redis 中的键

*按照字符串对象类型存储*

具有唯一性，是 kv 数据分区的依据

键命名可以用冒号间隔分段，表示不同键的关联性

删除策略

1. TTL
2. 可配置最大允许内存空间，将超限或者键到期时进行删除（==惰性删除、定期删除==）

### 数据类型

![image-20230410083712657](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230410083712657.png)

#### String

*最基本的存储类型*

一个键对应一个 SDS 类型值

String 类型不是用\0来判断字符串结束，是==二进制安全==的，即 String 类型可以是任何数据，并不局限于通常意义上的字符串

```C
struct sdshdrX{
  T len;	//实际字符串长度
  T alloc;	//预分配存储数据长度
  unsigned char flags;	//具体类型
  char buf[]; //数据存储区
}
```

- SDS 实现了**空间预分配**和**惰性空间释放**两种策略

#### List

*双向字符串列表，按照插入顺序排序*

#### Set

*String 类型的无序集合*

- 通过哈希表实现
- 集合内元素具有唯一性

#### Hash

*Hash 结构的值是一个键值对集合*

- value 是一个 map
- map 内部的 key 称为 field
- 特别适合用于存储对象

#### ZSet 有序集合

*与 set 不同的是每个元素都会关联一个 Double 类型的数值（score）*

- 可以根据 score 排序
- 成员要求唯一，但对应的 score 可以重复

#### Stream

*支持多播的消息队列机制*

- 消息链表，将所有加入的消息都穿起来，每个消息有一个唯一的 ID 和对应的内容
- 消息队列是持久化的，Redis 重启后内容还在
- 本质上是一个时序数据结构

![shadow-image-20230424154202253](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230424154202253.png)



## 键值数据库管理

### 持久化管理

*键值数据库的读写一般分为面向内存的读写和面向磁盘的读写*

Redis 使用了两种文件格式分别存储全量数据和增量请求数据

1. 全量数据格式文件：把内存中的数据快照写入磁盘，称作 RDB 方式
2. 增量请求数据文件：把内存中的数据序列化为写操作日志请求，通过读取文件重新执行写操作请求得到数据，称作 AOF 方式

#### Redis 持久化方案

1. RDB 持久化：在指定的时间间隔将内存中的数据集快照写入磁盘
   - 优点：
     1. 只有一份 RDB 文件，随时可备份
     2. 比 AOF 文件小，效率高
     3. 提供 FORK 子进程，不阻塞主进程，IO操作较少
2. AOF 持久化：将以日志的形式记录服务器所处理的每一个写操作
   - 优点：
     1. key 配置每次改动都同步数据，安全性好
     2. APPEND 方式追加日志，不会对旧日志文件产生影响
3. 无持久化：这样可以将 Redis 视为一个加强版的 memcached
4. 同时应用 AOF 和 RDB



### 分区机制

优点：

1. 可以构建更大的数据库，易于横向扩喊
2. 充分利用多台服务器计算存储能力进行负载均衡

问题：

1. 数据处理更复杂
2. 添加和删除服务器时，涉及重新分区、数据迁移等过程，复杂



分区机制：

1. 范围分区：映射一定范围 ID 的对象到特定的数据库实例，不足在于需要维护一个键区间范围到数据库实例的映射表
2. 哈希分区：使用一个 Hash 函数将key 转换为一个数字，根据这个数字映射 Redis 实例

执行分区任务的角色：

1. 客户端分区：客户端依据分区算法计算得到数据会被存储到哪个节点
2. 代理分区：客户端将请求发送给代理，由代理决定那个节点写数据或读数据，将节点的响应结果发送给客户端
3. 查询路由：客户端随机将请求发送给任意一个实例，改数据库会将请求转发给正确的数据节点



### 集群监控

Sentinel 机制

*哨兵是一个运行在特殊模式下的 Redis 服务器*

Master-Slave 架构，

1. 读写分离
2. 从节点也可以有从节点
3. 主、从节点均部署哨兵进程

烧饼执行三个任务

1. 监控：检查 Master 和 Replica 是否运行正常
2. 提醒：某个实例出现问题时，向管理员或其他程序发送通知
3. 自动故障迁移：当一个 Master 不能正常工作时，烧饼开始一次==自动故障迁移操作==
   - 将失效 Master 的其中一个 Replica 升级为 Master，并让其他 replica 修改主节点
   - 当客户端试图连接失效 Master 时，向客户端返回新 Master 的地址

基本概念：

1. 定时任务：
   1. 向主从节点发送消息获取最新拓扑结构
   2. 发布订阅功能获取其他烧饼的信息
   3. 向其他节点（所有节点）发送心跳检测
2. 主观下线：心跳检测时未得到回复的节点，将其主观下线
3. 客观下线：
   1. 对==主节点==主观下线后，会询问其他烧饼该主节点的状态
   2. 如果判断该主节点下线的烧饼数量达到一定值，则进行客观下线
4. 选举领导者哨兵节点
   1. 当主节点客观下线后，各个哨兵选举一个领导哨兵
   2. 由该哨兵进行故障迁移
   3. 选举使用 Raft 算法

