



## 消息队列

----

### 实验步骤

1. 编写 msgreceive.c 文件作为接受消息的进程，该程序完成以下功能：

   - 建立消息队列
   - 从消息队列中读取信息并打印在屏幕上
   - 当收到”end“消息时，删除消息队列并停止

   <img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20221208181140859.png" alt="image-20221208181140859" style="zoom:25%;" />

2. 编写 msgsend.c 文件作为发送消息的进程，该程序完成以下功能：

   - 建立消息队列
   - 通过标准输入流，向消息队列中写入信息
   - 写入”end“时停止

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20221208190625447.png" alt="image-20221208190625447" style="zoom:25%;" />

3. 编译 msgreceive.c 和 msgsend.c 文件
4. 分别运行 msgreceive.exe 和 msgsend.exe，其中 msgreceive.c 在后台运行
5. 根据提示在 send 端输入信息，receive 端即可打印出收到的信息
6. 输入 end 时程序停止运行

### 实验结果

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20221208203053851.png" alt="image-20221208203053851" style="zoom:25%;" />

### 源代码

msgreceive.c

```C
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <sys/msg.h>

struct msg_st {
    long int msg_type;
    char text[BUFSIZ];
};

int main() {

    int running = 1;
    int msgid = -1;
    struct msg_st data;
    long int msgtype = 0;

    msgid = msgget((key_t) 1234, 0666 | IPC_CREAT);
    if (msgid == -1) {
        fprintf(stderr, "msgget failed with error: %d\n", errno);
        exit(EXIT_FAILURE);
    }
    while (running) {
        if (msgrcv(msgid, (void *) &data, BUFSIZ, msgtype, 0) == -1) {
            fprintf(stderr, "msgrcv failed with errno: %d\n", errno);
            exit(EXIT_FAILURE);
        }
        printf("You wrote: %s\n", data.text);
        if (strncmp(data.text, "end", 3) == 0) {
            running = 0;
        }
    }
    if (msgctl(msgid, IPC_RMID, 0) == -1) {

        fprintf(stderr, "msgctl(IPC_RMID) failed\n");
        exit(EXIT_FAILURE);

    }
    exit(EXIT_SUCCESS);

}

```

msgsend.c

```c
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/msg.h>
#include <errno.h>

#define MAX_TEXT 512
struct msg_st {

    long int msg_type;

    char text[MAX_TEXT];
};

int main() {

    int running = 1;

    struct msg_st data;

    char buffer[BUFSIZ];

    int msgid = -1;

    msgid = msgget((key_t) 1234, 0666 | IPC_CREAT);
    if (msgid == -1) {
        fprintf(stderr, "msgget failed with error: %d\n", errno);
        exit(EXIT_FAILURE);
    }

    while (running) {
        printf("Enter some text: ");
        fgets(buffer, BUFSIZ, stdin);
        data.msg_type = 1;
        strcpy(data.text, buffer);
        if (msgsnd(msgid, (void *) &data, MAX_TEXT, 0) == -1)
        {
            fprintf(stderr, "msgsnd failed\n");
            exit(EXIT_FAILURE);
        }
        if (strncmp(buffer, "end", 3) == 0) {
            running = 0;
        }
        sleep(1);

    }

    exit(EXIT_SUCCESS);

}

```



## 共享内存

----

### 实验步骤

1. 编写 shmwrite.c 文件作为写共享内存的进程，该程序完成以下功能：
   - 创建一块新的共享内存
   - 映射该共享内存
   - 向共享内存中循环写入三个指定结构体`people{name,age}`
   - 解除映射

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20221208185717768.png" alt="image-20221208185717768" style="zoom:25%;" />

2. 编写 shmread.c 文件作为读取共享内存的进程，该程序坞完成以下功能：
   - 找到共享内存位置
   - 映射共享内存
   - 读取共享内存中的数据并打印在屏幕上
   - 解除映射

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20221208182037250.png" alt="image-20221208182037250" style="zoom:25%;" />

3. 分别变异 shmwrite.c 和 shmread.c
4. 先运行 shmwrite，再运行 shmread，即可看到从 shmwrite 程序写入的数据

### 实验结果

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20221208185831823.png" alt="image-20221208185831823" style="zoom:25%;" />

### 源代码

shmwrite.c

```c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/types.h>
#include <unistd.h>
#include <strings.h>


typedef struct {
    char name[8];
    int age;
} people;

int main(int argc, char **argv) {
    int shm_id, i;
    key_t key;
    char temp[8];
    people *p_map;
    char pathname[30];
    strcpy(pathname, "/tmp");
    key = ftok(pathname, 0x03);
    if (key == -1) {
        perror("ftok error");
        return -1;
    }
    printf("key=%d\n", key);
    shm_id = shmget(key, 4096, IPC_CREAT | IPC_EXCL | 0600);


    if (shm_id == -1) {
        perror("shmgct error");
        return -1;
    }
    printf("shm_id=%d\n", shm_id);
    p_map = (people *) shmat(shm_id, NULL, 0);


    memset(temp, 0x00, sizeof(temp));
    strcpy(temp, "test");
    temp[4] = '0';
    for (i = 0; i < 3; i++) {

        temp[4] += 1;
        strncpy((p_map + i)->name, temp, 5);
        (p_map + i)->age = 0 + i;
    }
    shmdt(p_map);
    return 0;
}


```

shmread.c

```c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/types.h>
#include <unistd.h>
#include <strings.h>

typedef struct {
    char name[8];
    int age;
} people;

int main(int argc, char **argv) {


    int shm_id, i;
    key_t key;
    people *p_map;
    char pathname[30];
    strcpy(pathname,"/tmp");
    key = ftok(pathname, 0x03);
    if (key == -1) {

        perror("ftok error");

        return -1;
    }
    printf("key=%d\n",key);

    shm_id = shmget(key, 0, 0);

    if (shm_id == -1) {

        perror("shmget error");

        return -1;
    }

    printf("shm_id=%d\n", shm_id);

    p_map = (people *) shmat(shm_id, NULL, 0);

    for (i = 0; i < 3; i++) {
        printf("name:%s\n", (*(p_map + i)).name);
        printf("age:%d\n", (*(p_map + i)).age);

    }
    if (shmdt(p_map) == -1) {

        perror("detach error");

        return -1;
    }
    return 0;

}
```



## 命名管道

---

### 实验步骤

1. 编写 nppwrite.c 文件作为向管道中写入数据的进程，实现以下功能：
   - 创建命名管道
   - 从标准输入流中写入消息到管道中
   - 当输入为空时结束进程

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20221208182342362.png" alt="image-20221208182342362" style="zoom:25%;" />

2. 编写 nppread.c 文件作为从管道中读取数据的进程，实现以下功能：
   - 获取管道读取权限（加锁）
   - 读取管道中消息读取至缓冲区
   - 打印缓冲区消息至屏幕上
   - 解锁

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20221208182426304.png" alt="image-20221208182426304" style="zoom:25%;" />

3. 分别编译 nppwrite.c 和 nppread.c 文件
4. 运行 nppwrite，同时打开另一个终端运行 nppread
5. 在 nppwrite 程序中根据提示信息输入消息
6. 在 nppread 终端查看消息

### 实验结果

nppwrite

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20221208182851551.png" alt="image-20221208182851551" style="zoom:25%;" />

nppread

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20221208182905372.png" alt="image-20221208182905372" style="zoom:25%;" />

### 源代码

nppwrite.c

```c
#include<stdlib.h>
#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<string.h>
#include<errno.h>
#include<fcntl.h>

#define PATH "./fifo"
#define SIZE 128

int main() {

    int fd = open(PATH, O_WRONLY);
    if (fd < 0) {
        perror("open error");
        exit(0);
    }

    char Buf[SIZE];
    while (1) {
        printf("please Enter#:");
        fflush(stdout);
        ssize_t s = read(0, Buf, sizeof(Buf));
        if (s < 0) {
            perror("read is failed");
            exit(1);
        }
        else if (s == 0) {
            printf("read is closed!");
            return 1;
        }
        else {

            Buf[s] = '\0';

            write(fd, Buf, strlen(Buf));
        }
    }
    return 0;
}


```

nppread.c

```c
#include<stdlib.h>
#include<stdio.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<errno.h>
#include <unistd.h>

#define PATH "./fifo"
#define SIZE 128

int main() {

    umask(0);
    if (mkfifo(PATH, 0666 | S_IFIFO) == -1) {
        perror("mkefifo error");
        exit(0);
    }
    int fd = open(PATH, O_RDONLY);
    if (fd < 0) {
        printf("open fd is error\n");
        return 0;
    }

    char Buf[SIZE];
    while (1) {
        ssize_t s = read(fd, Buf, sizeof(Buf));
        if (s < 0) {
            perror("read error");
            exit(1);
        } else if (s == 0) {
            printf("client quit! i shoud quit!\n");
            break;
        } else {

            Buf[s] = '\0';

            printf("client# %s ", Buf);
            fflush(stdout);
        }
    }
    close(fd);
    return 3;
}


```



## 信号（软中断）

----

### 实验步骤

1. 编写 signal.c 文件，该程序实现以下功能：
   - 创建两个子进程
   - 捕捉从键盘输入的中断信号，若收到信号，删除已创建的子进程
   - 若在 5 秒内未收到中断信号，自动删除两个子进程
   - 删除子进程后父进程也终止

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20221208183000344.png" alt="image-20221208183000344" style="zoom:25%;" />

2. 编译并运行 signal.c，在不同的时间内按下 `ctrl+c`
3. 查看结果



### 实验结果

1. 不进行任何操作，5 秒后两个子进程先后被删除

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20221208183139859.png" alt="image-20221208183139859" style="zoom:25%;" />

2. 程序开始运行后按下 `ctrl+c`，父进程收到软终端，分别删除子进程后自己终止

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20221208220252405.png" alt="image-20221208220252405" style="zoom:25%;" />

### 源代码

signal.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include<sys/wait.h>
#include <unistd.h>
#include <sys/types.h>

int flag_wait = 1;

void stop2() {
    flag_wait = 0;
    printf("\nson interruption\n");

}

void stop() {
    printf("\ninterruption\n");
}

int main() {

    pid_t pid1, pid2;
    signal(3, stop);

    while ((pid1 = fork()) == -1);
    if (pid1 > 0) {

        while ((pid2 = fork()) == -1);
        if (pid2 > 0) {
            sleep(5);
            kill(pid1, 16);
            wait(0);
            kill(pid2, 17);
            wait(0);
            printf("\nParent process is killed\n");
            exit(0);

        } else {

            signal(17, stop2);
            while (flag_wait);
            printf("\nchild process 2 is killed\n");
            exit(0);

        }

    } else {

        signal(16, stop2);
        while (flag_wait);
        printf("\nchild process 1 is killed\n");
        exit(0);

    }
    return 0;

}


```





