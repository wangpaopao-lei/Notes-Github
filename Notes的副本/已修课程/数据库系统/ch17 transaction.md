## Outline

1. ![image-20221122150005864](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20221122150005864.png)

## 目录

[toc]





# 事务

操作的集合，构成了一个逻辑上完整的单位

两个主要问题：

1. 多种错误
2. 并发事务

## ACID Properties

---

1. 原子性
2. 一致性：事务执行前后都要保证数据库一致性（由事务编写保证）
3. 隔离性：事务的执行是并发调度，但执行的效果要好像是单独执行一样，不受影响（由事务并发控制保证）
4. 持久性：事务一旦提交，影响永久生效





## 事务状态

==active==活动

==partially committed==部分提交

==failed==失败

==aborted==退出

==committed==成功提交

![image-20221122152212379](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20221122152212379.png)



## 事务调度

---

为什么要并发

1. 提升不同资源利用率
2. 减少平均响应时间



并发事务执行的顺序

两个条件

1. 要保证所有事务包含其所有操作
2. 保证每个事务内操作的相对顺序



### serializability 可串行化调度

串行调度一定能保证一致性，因此并发调度应以串行结果作为参考。

若并发调度可以等价于某个串行调度，那么可以证明这个调度是正确的，称之为可串行化

1. 冲突可串行
2. 视图可串行



冲突操作：改变操作顺序结果会不一样

比如对同一数据的读写操作

冲突等价：通过调换调度中的非冲突操作得到另一个等价的调度——这俩调度冲突等价

如果能找到冲突等价的串行调度，则该调度==冲突可串行==



证明冲突可串行：

画前驱图，若无环，则冲突可串行

如何生成等价串行调度？

1. 找到入度为 0 的节点，去掉其边
2. 在剩下的图中找入度为 0 的点
3. 重复



### recoverability 可恢复调度

可恢复调度：==读事务的提交==一定要在写事务提交（不能再回滚）之后



### cascading rollback 级联回滚调度

==读事务==要在写事务提交之后

一个事务回滚会带来其他事务回滚

无级联回滚的调度一定是可恢复调度



作业 1

1. 画前驱图，判断是否冲突可串行
2. 如果是，找出等价串行调度

![image-20221129141928305](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20221129141928305.png)

作业 2

1. 画前驱图，判断是否冲突可串行
2. 如果是，找出等价串行调度
3. 是否可恢复
4. 是否无级联回滚

![image-20221129141946761](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20221129141946761.png)