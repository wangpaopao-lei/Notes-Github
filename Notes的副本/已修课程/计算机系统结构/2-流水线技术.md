## contents

[toc]



# 流水线技术

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230409164352188.png" alt="shadow-image-20230409164352188" style="zoom:50%;" />

![shadow-image-20230409164403791](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230409164403791.png)

## 基本概念

### 概述

- 每个子过程及其功能部件成为流水线的级或段 stage
- 流水线的段数称为流水线深度 depth

#### 指令流水线

把指令的==解释过程==分解为**译码**、**执行**两个子过程

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230409170641555.png" alt="shadow-image-20230409170641555" style="zoom:50%;" />

#### 浮点加法流水线

*运算操作流水线、部件级流水线*

把浮点加法分解为**求阶差、对阶、尾数相加、规格化**四个子过程

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230409170812080.png" alt="shadow-image-20230409170812080" style="zoom:50%;" />

#### 时空图

*横坐标代表时间、纵坐标代表流水线的各个段*

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230409170930522.png" alt="shadow-image-20230409170930522" style="zoom:50%;" />

#### 特点

1. 流水线中各个段的时间应尽可能相等，否则会引起堵塞、断流
   - 时间最长的段将成为流水线的瓶颈
2. 流水线的每个段后面都要有一个缓冲寄存器（锁存器），称为**流水寄存器**
   - 在相邻两段之间传送数据，以保证提供后面要用到的信息，并*把处理工作相互隔离*
3. 流水线适合大量重复的时序过程，只有在输入端源源不断提供任务，才能充分发挥流水线的效率



### 流水线分类

#### 按照用于计算机系统的等级

- 部件级流水线（运算操作流水线）
- 处理机流水线（指令流水线）
- 系统级流水线（宏流水线）：把多台处理机串行连接起来，对同一数据流进行处理，每个处理机完成任务中的一部分

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230409171500744.png" alt="shadow-image-20230409171500744" style="zoom:50%;" />

#### 按流水线完成的功能

- 单功能流水线
- 多功能流水线：各段可以进行不同的连接，以实现不同的功能

#### 按同一时间各段的连接方式（多功能）

- 静态流水线：同一时间内，多功能流水线的各段只按同一种功能的连接方式工作；切换时，必须等到前面的任务都出流水线。
- 动态流水线：在同一时间内，各段可以按照不同方式连接，同时执行多种功能
  - 优点：灵活
  - 缺点：控制复杂

#### 按是否有反馈回路

- 线性流水线：各段串行连接，没有反馈回路
- 非线性流水线：有些段可能重复通过
  - 调度问题

## 性能指标

### 吞吐率

 *在单位时间内流水线所完成的任务数量或输出结果的数量。*
$$
T P=\frac{n}{T_k}
$$

#### 各段时间相等的流水线

对 k 段流水线，完成连续 n 个任务需要
$$
T_k=k \Delta t+(n-1) \Delta t=(k+n-1) \Delta t
$$
实际吞吐率
$$
T P=\frac{n}{(k+n-1) \Delta t}
$$
最大吞吐率
$$
T P_{\max }=\lim _{n \rightarrow \infty} \frac{n}{(k+n-1) \Delta t}=\frac{1}{\Delta t}
$$

#### 各段时间不完全相等的流水线

最长的段称为**瓶颈段**

实际吞吐率为
$$
T P=\frac{n}{\sum_{i=1}^{k} \Delta t_{i}+(n-1) \max \left(\Delta t_{1}, \Delta t_{2}, \cdots, \Delta t_{k}\right)}
$$


最大吞吐率为
$$
T P_{\max } = \frac{1}{\max \left(\Delta t_{1}, \Delta t_{2}, \cdots \Delta t_{k}\right)}
$$


#### 解决瓶颈问题的常用方法

1. 细分瓶颈
2. 重复设置瓶颈

### 加速比

#### 各段相等的流水线

*同样一批任务，不使用流水线使用的**时间**与使用流水线所用的时间之比*

实际加速比
$$
S=\frac{nk}{k+n-1}
$$
最大加速比
$$
S_{max}=lim_{n\rightarrow\infty}\frac{nk}{k+n-1}=k
$$


#### 各段不完全相等的流水线

$$
S=\dfrac{n\sum_i^k\Delta t_i}{\sum_i=1^k\Delta t_i+(n-1)\max(\Delta t_i,\Delta t_2,...,\Delta t_k)}
$$

### 效率

*实际使用时间与整个运行时间的比值，即流水线的设备利用率*

- 是实际加速比 S 与它的最大加速比 k 的比值

$$
E=\frac{S}{k}
$$

- 从时空图上看，效率就是 n 个任务占用的时空面积和 k 个段总的时空面积之比

### 若干问题

1. 瓶颈问题：各段不均匀的时候，机器的时钟周期取决于瓶颈段的延迟时间
2. 流水线的额外开销
   - 流水寄存器需要额外建立时间和传输延迟
   - 时钟偏移开销：时钟到达各流水寄存器的最大差值时间、
3. 冲突问题：后面计算要用到前面的计算结果



## 非线性流水线调度

### 单功能流水线的最优调度

**启动距离**：向一条流水线的输入端连续输入两个任务之间的时间间隔

**禁用启动距离**：会引起非线性流水线功能段使用冲突的启动距离

一般都用时钟周期数来表示

#### 1 预约表

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230409194721942.png" alt="shadow-image-20230409194721942" style="zoom:50%;" />

#### 2 禁止表F

1. 对预约表中的每一行的任意一对✅，用它们的列号相减
2. 列出各种可能的差值
3. 删除相同的，剩下的就是禁止表的元素

*禁止表仅考虑了相连两个任务之间的冲突，然而不相连的任务也会发生冲突*

#### 3 冲突向量 $C_0$

*根据禁止表F 写出初始冲突向量 $C_0$，从一个集合到一个二进制串的转换*

冲突向量 C：一个 N 位的二进制位串

设 $C_0=（C_NC_{N-1}\dots C_i\dots C_2C_1)$

- $C_i=1$， i 在禁止表内（不允许间隔 i 个时钟周期后送入后续任务）
- $C_i=0$， i 不在禁止表内

#### 4 状态转换图

1. 当第一个任务进入流水线后，初始冲突向量决定了下一个任务需要间隔多少个时钟周期才可以流入

2. 在第二个任务流入后，假设第二个任务是与第一个任务间隔 j 个时钟周期流入的，此时，由于第一个任务已经在流水线中前进了 j 个时钟周期，相应的禁止表中各元素都应该减去 j
3. 再将第二个任务的禁止表纳入冲突向量中

$$
SHR^{(j)}(C_0)\or C_0
$$

4. 反复使用所有允许的时间间隔都按上述步骤求出新的冲突向量，直到不产生新的冲突向量为止

![shadow-image-20230410113501296](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230410113501296.png)

#### 5 根据状态转换图写出最优调度方案

1. 由初始状态出发，任何一个闭合回路即为一种调度方案
2. 列出所有调度方案，计算每种方案的平均时间间隔
3. 找出其中最小的即为**最优调度**

![shadow-image-20230410113649199](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230410113649199.png)

### 多功能非线性流水线的调度

以双功能（功能 A 和功能 B）为例

#### 1 节点状态表示

由两个冲突向量构成冲突矩阵，分别对应下一个任务的功能分别为 A 类和 B 类的情况

#### 2 初始节点

*有两个初始节点，分别对应第一个任务*

![shadow-image-20230411181231776](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230411181231776.png)

其中，$C_{pq}$ 表示，p 类任务流入时，对后续 q 类任务的冲突向量

这种冲突向量有$N^2$个

#### 3 后续冲突矩阵

![shadow-image-20230411183825927](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230411183825927.png)

把当前状态MK 中的各冲突向量逻辑右移 i 位，再与初始矩阵进行或运算、

#### 4 最优调度

# 待完成

## 相关与冲突

### 经典的五段 RISC 流水线

1. 取指令周期 IF
   - 以 PC 内容作为地址，从存储器中取出指令并放入指令寄存器 IR
   - PC+4
2. 译码周期 ID
   - 对指令进行译码，用 IR中的地址去访问通用寄存器组，读出需要的操作数
3. 执行周期 EX：不同指令操作不同
   - load/store：ALU 把指令中指定的寄存器内容与偏移量相加， 形成访存==有效地址==
   - 寄存器-寄存器：从通用寄存器取出数据晕眩
   - 寄存器-立即数：从通用寄存器取出操作数，和立即数计算
   - 分支指令：把指令中给出的偏移量与 PC 相加，形成转移的目标地址，同时，对前一个周期读出的操作数进行判断，确定分支是否成功
4. 存储器访问/分支完成周期 MEM：
   - 该周期只处理 load/store/分支指令
   - load：用上一个周期计算出的有效地址读出数据
   - store
   - 分支：分支成功，就把转移目标送入 PC
5. 写回周期 WB
   - 运算指令和 load 指令把结果数据写入通用寄存器



- 分支指令需要 4 周期（如果把分支的执行提取到 ID 周期，则只需要 2 个）
- store 指令需要 4 周期
- 其他指令需要 5 周期

### 相关与流水线冲突

#### 相关

dependence

##### 数据相关

两条指令 i 和 j

1. j 使用 i 产生的结果
2. j 与指令 k 数据相关，而 k 又与 i 数据相关（传递性）

##### 名相关

名：存储器单元或寄存器的名字

1. 反相关：j 写的名与 i 读的名相同，则发生了反相关
2. 输出相关：j 和 i 写相同的名，则发生了输出相关

*名相关的两条指令间并没有数据的传送*

*如果一条指令中的名改变，并不影响另一条指令的执行*

==换名技术==：通过改变指令中的操作数的名来消除名相关，对于寄存器操作数进行换名称为寄存器换名（既可以用编译器静态实现，也可以用硬件动态完成）

##### 控制相关

由分支指令引起的相关

![shadow-image-20230415142449021](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230415142449021.png)

#### 流水线冲突

*由于相关的存在，使得指令流汇总的下一条指令不能在指定的时钟周期执行*



##### 结构冲突

原因：

- 功能部件不是完全流水
- 资源份数不够

解决办法：

1. 插入暂停周期（气泡）
2. 设置相互独立的存储器或 cache



##### 数据冲突

*当相关的指令靠的足够近时，在流水线中的重叠执行或者重新排序会改变指令读写操作数的顺序，使之不同于串行执行的顺序*

==定向技术==：解决数据冲突引起的停顿。在计算结果尚未出来之前，后面等待该结构的指令并不真正立即需要该结果，如果能将该结果从产生的地方直接送到其他指令需要它的地方，就可以避免停顿

==需要停顿的数据冲突==：流水线互锁机制（插入暂停），检测到数据冲突，并使流水线停顿，直至冲突消失

**依靠编译器解决数据冲突**：指令调度/流水线调度



##### 控制冲突

分支指令有两种结果：

1. 成功，PC 值改变为目标地址
2. 不成功，PC 值正常递增

处理分支最简单的方法：冻结 或 排空

![shadow-image-20230415143821726](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230415143821726.png)

采取两种方法来减少分支延迟

1. 在流水线中尽早判断分支转移是否成功
2. 尽早计算出分支目标地址

假设 MEM 段工作提前到 ID 段完成

###### 三种通过软件（编译器）减少分支延迟的方法

1. 预测分支失败：允许分支指令后的指令继续在流水线中流动
   - 若分支失败，将分支指令看成一条普通指令
   - 若分支成功，将分支指令后取出的所有指令转化为空操作
2. 预测分支成功
3. 延迟分支：从逻辑上延长分支指令执行时间，把延迟分支看成由原来的分支指令和若干延迟槽构成，不管成功与否都要按顺序执行延迟槽中的指令

![shadow-image-20230415144825322](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230415144825322.png)

##### 分支延迟指令的调度

任务：*在延迟槽中放入有用的指令*

1. 从前调度
2. 从目标处调度
3. 从失败处调度

![shadow-image-20230415150240859](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230415150240859.png)

受两方面限制：

1. 可以放入延迟槽的指令需要满足一定的条件
2. 编译器预测分支转移方向的能力

进一步改进

##### 分支取消

当分支实际执行方向与事先预测的一样时，执行分支延迟槽中的指令，否则就将分支延迟槽中的指令转化为一个空操作

![shadow-image-20230415150516892](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230415150516892.png)



## 流水线的实现


