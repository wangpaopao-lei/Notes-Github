

# TSP 问题的 B&B 解法

## 分支定界主要思想

有最小化的整数规划问题 A，相应的线性松弛规划问题为 B

若求解问题 A，先从解 B 开始，若其最优解不符合 A 的整数条件（得到的成本特别小，因为成本大是可以存在的），那么 B 的最优目标函数值必定是 A的最优目标函数值z*的下界，记作 Z；而 A的任意可行解的目标函数值将是 z\*的一个上界z

分支定界法就是将 A 的可行域化成子区域的方法，逐步增大 Z 和减小 z，最终求得最优解 z*



把全部可行解空间反复分割成越来越小的子集，称为分支；对每个子集内的解集计算一个目标下界，称为定界

（为什么这里是下界不是上界）。

> chatgpt：
>
> 1. 下界给的限制更紧凑，能保证孩子子问题的最优解一定不会超过该限制（孩子问题只会在这个基础上加）
> 2. 计算上界更困难，因为要找到其中的最优解；而计算下界可以通过松弛约束条件或启发式方法，比较容易得到一个相对紧凑的限制
>
> 我：
>
> 任务的目标不就是求一个最小值（上界）吗



在每次分支后，可能有三种情况：

1. 剪枝掉超出上界的子集
2. 剪枝掉不满足整数条件的解的子集
3. 满足整数条件且优于当前上界，用当前解替换上界



## TSP 问题

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230616135601872.png" alt="image-20230616135601872" style="zoom:33%;" />

找到一条最佳路径，遍历这七个点，每个点只遍历一次



## One-tree 算法

### 定界

onetree 用于分之后的定界计算（求下界——当前的最低成本）。

除了 one 访问点歪，对所有剩下的访问点通过 kruskal 算法求最小生成树，最后再用两条边将 one 访问点和最小生成树进行连接（一条边为进入最小生成树，一条边为走出最小生成树，构造 one 节点与最小生成树的回路）

通过 onetree 算法得到的解有三种情况：

1. 先不区分得到的解是否为 TSP 可行解，判断与上界的大小关系，如果大于上界直接剪枝
2. 当前解为可行解，且小于上界，用当前解替换当前最优解，将当前解的值作为上届的值
3. 当前解为不可行解，且小于上界，在当前解分支的基础上继续进行分支定界操作



### 分支

当定界得到情况三时，进行分支操作

onetree 算法求得的解会出现度大于等于3 的点，显然有这种点的解是不可行解

找到 onetree 中所有度大于等于 3 的节点边，枚举并将禁忌这些边作为分支条件，依次进行分支，继续定界

==onetree 树是可行解的充要条件是：所有节点的度均为 2==



比如过程中某两点的度大于等于三，列举他们的边的集合，对这些边进行分支操作（分支某条边，是指在后续的求解过程中禁忌这条边）





# 论文方法

## Intro

提出三种基于共享内存的 BB 并行方法来利用多核 CPU 处理器

1. 工作窃取的方法：多个并发实例并发搜索单个搜索树
2. 基于树的方法，由独立的 BB 实例同时搜索树的多个部分
   1. 主从模式：主节点将搜索树分解成多个部分交给从节点
   2. 进程间唯一共享的信息是上界值
   3. 问题：负载不均衡，不同从节点间的运行时间差别很大，引出方法 3
3. 提出两种负载均衡策略
   1. 将主节点当做负载均衡器，当有从节点空闲时从负载均衡器的工作池中选取一个子问题
   2. 将前两个并行方法结合起来，允许从节点在本地进行 k 次迭代，接着讲它们本地的工作池整合进一个共享的全局工作池



## 问题讲解

1. 顶点标记函数
2. 边标记函数
3. GED 操作：
   1. 点替换
   2. 点删除
   3. 点插入
   4. 边操作隐含在点操作中
4. 代价函数：可以令不同操作的代价不同

## GED 的分支定界算法

![image-20230628192931780](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230628192931780.png)
