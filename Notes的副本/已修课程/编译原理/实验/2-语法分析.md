![image-20230527165556298](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230527165556298.png)



# 语法分析程序实验报告



<center>
  姓名：王磊
</center>


<center>
  学号：2020211538
</center>

<center>
  提交日期：2023-5-27
</center>




## Content

[toc]

<div STYLE="page-break-after: always;"></div>

## 实验简介

### 开发环境

本程序在 MacOS 系统上开发，使用 C++语言编写，使用 Clang++17 编译器编译。

程序可在各平台下编译运行。

### 实验内容

- 编写语法分析程序，实现对算术表达式的语法分析。
- 在对输入的算术表达式进行分析的过程中,  依次输出所采用的产生式。
- 编写  LL(1)  语法分析程序。
- 编写语法分析程序实现自底向上的分析。

### 实验目的

- 掌握语法分析方法。
- 熟悉  LL，LR  语法分析方法以及编程实现。
- 程序能完成对指定语言的语法分析。
- 了解语法分析过程中的错误处理方式。

<div STYLE="page-break-after: always;"></div>*

## 概要

### 文件结构

```shell
.
├── SyntaxAnalyzerLL1.cpp
├── SyntaxAnalyzerLL1.h
├── SyntaxAnalyzerLR.cpp
├── SyntaxAnalyzerLR.h
├── conf
│   ├── lr.conf
│   └── lr.csv
├── report.pdf
└── result
    ├── LL1.out
    └── LR.out
```

- SyntaxAnalyzerLL1.cpp：LL(1) 代码文件
- SyntaxAnalyzerLL1.h：LL(1)  头文件
- SyntaxAnalyzerLR.cpp：LR 语法分析器代码文件
- SyntaxAnalyzerLR.h：LR 语法分析器头文件
- result：存放结果文件
  - LL1.out：LL1 语法分析器的测试结果
  - LR.out：LR 语法分析器的测试结果
- Conf：存放 LR 语法分析器配置文件
  - lr.conf：拓广文法
  - lr.csv：LR(0) 项目集规范簇
- report.pdf；实验报告

<div STYLE="page-break-after: always;"></div>



## LL(1) 语法分析程序

构造 LL(1) 语法分析程序的实验步骤由以下部分组成；

1. 构造 LL(1) 文法
2. 分析过程详解
3. 错误处理

### 构造 LL(1) 分析表

一个文法要能进行 LL(1) 分析，那这个文法应该满足：无二义性、无左递归、无左公因子。实验中给出的文法含有左递归。

#### 将文法改写成 LL(1) 文法

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/CamScanner%2005-27-2023%2017.06_1.jpg" alt="CamScanner 05-27-2023 17.06_1" style="zoom: 25%;" />



#### 构造 FIRST 集、FOLLOW 集、SELECT 集

FIRST(A)  集合是非终结符号  A  的所有可能推导出的开头终结符或    组成的集合。称  FIRST(A)  为 
A  的开始符号集或首符号集。对于大部分文法而言，存在一个产生式存在多个候选式的情况，而选择哪一个候选式是不确定的，所以这就产生了回溯。回溯需要消耗大量的计算、存储空间，所以我们需要消除回溯。而消除回溯的其中一 种方法叫作“预测”，即根据栈顶非终结符去预测后面的候选式，那预测方法就是求第一个非终结符，来判断是否和读头匹配，以达到预测的效果。

FOLLOW(A)   集合是所有紧跟   A   之后的终结符或\$ 所组成的集合（$   是句尾的标志），称   FOLLOW(A)  是  A  的随符集。当某一非终结符的产生式中含有空产生式时，它的非空产生式右部的开始符号集两两不相交，并与在推导过程中紧跟该非终结符右部可能出现的终结符集也不相交，则仍可构造确定的自顶向下分析。因此，引入了文法符号的后跟符号集合 FOLLOW。

SELECT 集也是⼀个⾮终结符能推导出的最左终结符的集合，但有对空产⽣式的优化。

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/CamScanner%2005-27-2023%2017.20(1)_1.jpg" alt="CamScanner 05-27-2023 17.20(1)_1" style="zoom: 33%;" />

![CamScanner 05-27-2023 17.22_1](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/CamScanner%2005-27-2023%2017.22_1.jpg)

#### 构造预测分析表

1. 先将所有⾮终结符放在⾏⾸，将所有终结符（要带上终⽌符$）放在列⾸。
2. 然后对于产⽣式左部为⾮终结符A的产⽣式，如果终结符x属于该产⽣式的SELECT 集，则Table\[A]\[x]填上该产⽣式右部；
3. 如果产⽣式是空产生式（A->ε），则对于该产⽣式的 SELECT集中的终结符x，Table\[A][x]填上该空产⽣式右部（->ε）.

得到预测分析表

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/CamScanner%2005-27-2023%2017.31_1.jpg" alt="CamScanner 05-27-2023 17.31_1" style="zoom:50%;" />

==构造分析表函数原型==

```C++
/*
 * @name:LL1_syntax_analyzer::create_predict_table
 * @attr1:g 文法
 * @attr2:fi FIRST 集
 * @attr3:fo FOLLOW 集
 *
 * @description:根据已知文法、求得的 FIRST 集、FOLLOW 集，计算预测分析表
 */
PREDICT_TABLE create_predict_table(GRAMMAR_TABLE g, FIRST_TABLE fi,FOLLOW_TABLE fo);
```



### 分析过程详解

预测分析程序的总控程序在任何时候都是按  STACK  栈顶符号  X  和当前的输入符号  a  行事的。如下 
图所示，对于任何  (X,a)，总控程序每次都执行下述三种可能的动作之一：

1. 若  X  =  a  =  ‘$’，则宣布分析成功，停止分析过程。
2. 若  X  =  a  !=  ‘$’，则把  X  从  STACK  栈顶弹出，让  a  指向下一个输入符号。
3. 若  X  是一个非终结符，则查看分析表  M。
4. 若  M[X,a]  中存放着关于  X  的一个产生式，那么，先把  X  弹出  STACK  栈顶，然后把产生式的右部 
   符号串按反序一一推进  STACK  栈（若右部符号为  ϵ，则意味着不推什么东西进栈）。
5. 若  M[X,a]  中存放着“出错标志”，则调用出错诊断程序  ERROR

==预测分析函数原型==

```c++
/* @name:LL1_syntax_analyzer::predict_analyze
 * @attr1:input 输入的待分析字符串
 * @attr2:pt 预测分析表
 *
 * @description:对照预测分析表，对输入字符串进行预测分析
 */
ANALYZE_TABLE predict_analyze(string input,PREDICT_TABLE pt);
```



### 错误处理

在 LL(1) 预测分析程序中，共设计了 种不同的异常，当发现错误时，错误输出函数会立即打印错误以及 log 内容，同时根据错误类别选择终止程序或直接忽略

- Exception2：栈顶元素是终结符，但不与缓冲区开头元素匹配
- Exception3：分析表表头找不到对应字符串
- Exception4：查询分析表过程中查到了 error 项
- Exception5：符号栈栈顶既不是终结符也不是非终结符，即出现了不属于该文法的符号
- Exception6：符号栈已空时缓冲区还未读完

==错误输出函数原型==

```C++
/* @name:LL1_syntax_analyzer::error
 * @attr1:input 错误信息
 *
 * @description:对错误 e 进行输出
 */
void error(string e);
```

<div STYLE="page-break-after: always;"></div>

## LR 语法分析程序

构造 LR 分析程序由以下几个步骤构成

1. 构造拓广文法
2. 构造 LR(0) 有效项目簇 DFA
3. 如存在移近-归约冲突，则计算每个终结符的 FOLLOW 集合
4. 如果用 FOLLOW 集合就能解决冲突，则为 SLR(1) 文法
5. 如果不能解决冲突，则重新构造该文法的 LR(1) 有效项目簇 DFA
6. 根据 DFA 构造 LR 分析表



### LR 分析表的构造



#### 构造拓广文法

增加一条右部位开始符号的产生式，构造出只有一个入口的文法。

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/CamScanner%2005-27-2023%2019.33_1.jpg" alt="CamScanner 05-27-2023 19.33_1" style="zoom: 25%;" />

程序中，该文法存储在 lr1.conf 文件里，调用 load_formula 函数读取

==读取文法函数原型==

```C++
vector<pair<string,string>> _formula;
void load_formula(string fileName);
```



#### 构造 LR(0) 有效项目簇 DFA

使用算法 4.5 构造文法的 LR(0) 项目集规范簇得到 DFA

<img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/CamScanner%2005-27-2023%2019.50_1.jpg" alt="CamScanner 05-27-2023 19.50_1" style="zoom:25%;" />



#### 判断 LR 文法种类

由 DFA 可知，该项目集规范簇存在移近-归约冲突，但是通过 FOLLOW 集就可以解决，所以该文法是 SLR(1) 文法，只需在此基础上构造 SLR(1) 分析表即可

#### 构造 SLR(1) 分析表

|      | +    | -    | *    | /    | (    | )    | num  | $    | E'   | E    | T    | F    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    |      |      |      |      | S4   |      | S5   |      |      | 1    | 2    | 3    |
| 1    | S6   | S7   |      |      |      |      |      | ACC  |      |      |      |      |
| 2    | R3   | R3   | S8   | S9   |      | R3   |      | R3   |      |      |      |      |
| 3    | R6   | R6   | R6   | R6   |      | R6   |      | R6   |      |      |      |      |
| 4    |      |      |      |      | S4   |      | S5   |      |      | 10   | 2    | 3    |
| 5    | R8   | R8   | R8   | R8   |      | R8   |      | R8   |      |      |      |      |
| 6    |      |      |      |      | S4   |      | S5   |      |      |      | 11   | 3    |
| 7    |      |      |      |      | S4   |      | S5   |      |      |      | 12   | 3    |
| 8    |      |      |      |      | S4   |      | S5   |      |      |      |      | 13   |
| 9    |      |      |      |      | S4   |      | S5   |      |      |      |      | 14   |
| 10   | S6   | S7   |      |      |      | S15  |      |      |      |      |      |      |
| 11   | R1   | R1   | S8   | S9   |      | R1   |      | R1   |      |      |      |      |
| 12   | R2   | R2   | S8   | S9   |      | R2   |      | R2   |      |      |      |      |
| 13   | R4   | R4   | S8   | S9   |      | R4   |      | R4   |      |      |      |      |
| 14   | R5   | R5   | R5   | R5   |      | R5   |      | R5   |      |      |      |      |
| 15   | R5   | R5   | R7   | R7   |      | R7   |      | R7   |      |      |      |      |



在编程实现中，为了降低程序复杂度，令每一个状态转移到的都是一个新状态，存储在 lr1.csv 文件中。

==读取分析表函数原型==

```C++
typedef map<string,map<string,string>> ANALYZE_TABLE;
void load_table(string fileName);
```



### 分析过程

LR  分析方法：把“历史”以及“展望”综合抽象成状态；由栈顶的状态和现行的输入符号唯一确定每一 
步工作。

每一个符号对应一个状态，分析栈每次弹出一个符号，就要把对应的状态也弹出。然后  LR  分析程序 
会根据输入串在  LR  分析表中进行查找：是进行归约、移进还是报错操作。

LR  分析器实质上是一个带先进后出存储器（栈）的确定有限自动机，其核心部分是一张分析表，包 
括两部分：

1. ACTION[s，a] 动作表，规定当状态 s 面临输入符号 a 时，应采取什么动作（移进、归约、接受、 
   报错）【也就是告诉我们当栈顶状态为 s 时，输入的符号是 a 时，我们应该采取什么操作：归约、移进还是报错】
2. GOTO[s，X]  状态转换表规定了状态  s  面对文法符号  X  时，下一状态是什么。【当归约完了后， 
   要把规约后的非终结符压到栈里面的时候，跟新压入栈的这个非终结符所对应的状态是什么】



## 测试及结果分析

### 测试样例

```
3+(5-9*2/3)
```

### LL(1) 分析结果

==存储在 LL1.out 中==

![image-20230527200237232](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230527200237232.png)

### LR 分析结果

==存储在 LR.out 中==

![image-20230527200348915](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230527200348915.png)

<div STYLE="page-break-after: always;"></div>

## 附录

### 测试样例

```
3+(5-9*2/3)
```



### LL(1) 分析程序源代码

==LL1.h==

```C ++
//
// Created by 王跑跑跑 on 2023/5/13.
//

#include "string"
#include "map"
#include "fstream"
#include "iostream"
#include "vector"
#include "algorithm"

using namespace std;
//FIRST 集合，N-》T 数组
typedef map<string, vector<string>> FIRST_TABLE;
// FOLLOW 集合，N-》T 数组加上$
typedef map<string, vector<string>> FOLLOW_TABLE;
//分析过程，二维字符串数组,符号栈、待处理字符串、输出产生式
typedef vector<vector<string>> ANALYZE_TABLE;

class GRAMMAR_TABLE{
public:
    // 非终结符
    vector<string> N;
    // 终结符
    vector<string> T;
    // 产生式，N-》终结符和非终结符的组合
    map<string,vector<string>> P;
    // 开始符
    string S;

};

// 预测分析表
class PREDICT_TABLE{
public:
    // 终结符
    vector<string> terminals;
    // 非终结符
    vector<string> non_terminals;
    // 表，终结符-》非终结符-》产生式
    map<string,map<string,string>> table;
    // 开始符
    string start_symbol;
};

class LL1_syntax_analyzer{
public:
    /*
 * @name:LL1_syntax_analyzer::create_predict_table
 * @attr1:g 文法
 * @attr2:fi FIRST 集
 * @attr3:fo FOLLOW 集
 *
 * @description:根据已知文法、求得的 FIRST 集、FOLLOW 集，计算预测分析表
 */
    PREDICT_TABLE create_predict_table(GRAMMAR_TABLE g, FIRST_TABLE fi,FOLLOW_TABLE fo);
    /* @name:LL1_syntax_analyzer::predict_analyze
    * @attr1:input 输入的待分析字符串
    * @attr2:pt 预测分析表
    *
    * @description:对照预测分析表，对输入字符串进行预测分析
    */
    ANALYZE_TABLE predict_analyze(string input,PREDICT_TABLE pt);
//    打印预测分析表
    void print_predict_table(PREDICT_TABLE pt);
//    打印分析过程
    void print_analyze_table(ANALYZE_TABLE at);
//    错误输出
/* @name:LL1_syntax_analyzer::error
    * @attr1:input 错误信息
    *
    * @description:对错误 e 进行输出
    */
    void error(string e);

};

/*
 * @name:init
 * @attr1:&g
 * @attr2:&fi
 * @attr3:&fo
 *
 * @description:根据题目要求改写文法的生成式，计算得到 FIRST 集合和 FOLLOW 集合
 */
void init(GRAMMAR_TABLE &g,FIRST_TABLE &fi,FOLLOW_TABLE &fo);


int startWith(string str, string pattern);

string process(string str);
```

==LL1.cpp==

```C++
//
// Created by 王跑跑跑 on 2023/5/13.
//

#include "main.h"

using namespace std;

int startWith(string str, string pattern)
{
    return str.find(pattern) == 0 ? 1 : 0;
}

PREDICT_TABLE LL1_syntax_analyzer::create_predict_table(GRAMMAR_TABLE g, FIRST_TABLE fi, FOLLOW_TABLE fo) {
    PREDICT_TABLE pt;
    pt.table.insert(pair<string, map<string, string>>("E", map<string, string>()));
    pt.table.insert(pair<string, map<string, string>>("G", map<string, string>()));
    pt.table.insert(pair<string, map<string, string>>("T", map<string, string>()));
    pt.table.insert(pair<string, map<string, string>>("U", map<string, string>()));
    pt.table.insert(pair<string, map<string, string>>("F", map<string, string>()));

    for (auto iter = g.P.begin(); iter != g.P.end(); iter++) {
//iter 为产生式，x 为产生式左部非终结符
        string x = iter->first;
//填有产生式的格子
//iter2 为产生式右部（每一个单独的产生式）

        for (auto iter2 = iter->second.begin(); iter2 != iter->second.end(); iter2++) {

            string input = *iter2;
            //判断是终结符还是非终结符还是空，如果是非终结符，select 集合需要计算它的FIRST 集合，
            if (input[0] >= 'A' && input[0] <= 'Z') {

                vector<string> V_fi = fi.find(string(1, input[0]))->second;
//                遍历该产生式的 select 集合
                for (auto a = V_fi.begin(); a != V_fi.end(); a++) {

                    if (*a != "ε") {
                        pt.table.find(x)->second.insert(pair<string, string>(*a, input));
                    }
                }
//判断这个 select 集中是否有空
                if (find(V_fi.begin(), V_fi.end(), "ε") != V_fi.end()) {
//                    找到这个非终结符的 FOLLOW 集
                    vector<string> V_fo = fo.find(x)->second;
//                    遍历 FOLLOW 集
                    for (auto b = V_fo.begin(); b != V_fo.end(); b++) {

                        if (*b != "ε") {
                            pt.table.find(x)->second.insert(pair<string, string>(*b, input));
                        }
                    }
                }
            } else {
//                如果是终结符，select 集合就是它本身，如果是空，计算左部的 FOLLOW 集合
                string first_input;
                if (startWith(input, "num")) {
                    first_input = "num";
                } else if (startWith(input, "ε")) {
                    first_input = "ε";
                } else {
                    first_input = input[0];
                }
                if (first_input != "ε") {
                    pt.table.find(x)->second.insert(pair<string, string>(first_input, input));
                }
                if (first_input == "ε") {

                    vector<string> V_fo = fo.find(x)->second;
                    for (auto b = V_fo.begin(); b != V_fo.end(); b++) {
                        if (*b != "ε") {
                            pt.table.find(x)->second.insert(pair<string, string>(*b, input));
                        }
                    }
                }
            }

        }
    }
    for (auto iter = g.N.begin(); iter != g.N.end(); iter++) {
        string x = *iter;
        for (auto iter2 = g.T.begin(); iter2 != g.T.end(); iter2++) {
            string a = *iter2;
            if (pt.table.find(x)->second.find(a) == pt.table.find(x)->second.end()) {
                pt.table.find(x)->second.insert(pair<string, string>(a, "error"));
            }
        }
    }
    pt.non_terminals = g.N;
    pt.terminals = g.T;
    pt.start_symbol = g.S;
    return pt;
}

ANALYZE_TABLE LL1_syntax_analyzer::predict_analyze(string input, PREDICT_TABLE pt) {
//    分析过程记录表
    ANALYZE_TABLE at;

    int ip=0;
//    输入字符串结尾加上$符
    input+="$";

    vector<string> stack;
    stack.push_back("$");
    stack.push_back(pt.start_symbol);

    while(stack.size()!=1){

        vector<string> item;
        at.push_back(item);
//        符号栈以["开头
        string stack_str="[\"";
//遍历符号栈
        for(auto iter=stack.begin();iter!=stack.end();iter++){
//            符号栈字符串中的字符用","隔开
            stack_str+=*iter+"\",\"";
        }
//删除最后两个字符
        stack_str.erase(stack_str.length()-2,2);
        stack_str+="]";
//        把符号栈加入分析过程表
        at.back().push_back(stack_str);
//        提取输入字符串的子串，从 ip 开始直到末尾
        string input_str=input.substr(ip);
//        把缓冲区加入分析过程表
        at.back().push_back(input_str);

//        取符号栈栈顶元素
        string x=stack.back();
//判断栈顶元素是否为终结符
        if(find(pt.terminals.begin(),pt.terminals.end(),x)!=pt.terminals.end()){
//如果栈顶是终结符，判断是否与 buf 中开头的元素相同
            if(startWith(input.substr(ip),x)){
//                如果相同，即为匹配上了，一起弹出
                ip+=x.size();
                stack.pop_back();
            }
            else{
//                exception2 代表栈顶元素是终结符，但不与 buf 开头元素匹配
                error("exception2 "+x);
                return at;
            }
        }
//        判断栈顶元素是否是非终结符
        else if(find(pt.non_terminals.begin(),pt.non_terminals.end(),x)!=pt.non_terminals.end()){
//            buf 开头元素
            string input_str_first;
//            判断是否为 num
            if(input[ip]=='n'&&input[ip+1]=='u'&&input[ip+2]=='m'){
                input_str_first="num";
            }
            else{
                input_str_first=input.substr(ip,1);
            }



//            cout<<x<<endl;
//            cout<<input_str_first<<endl;
//            for (const auto& outerPair : pt.table) {
//                std::cout << "Outer Key: " << outerPair.first << std::endl;
//                for (const auto& innerPair : outerPair.second) {
//                    std::cout << "Inner Key: " << innerPair.first << ", Value: " << innerPair.second << std::endl;
//                }
//                std::cout << std::endl;
//            }




//            判断栈顶元素在预测分析表中是否有对应行，M[A,a]中的 a 是否有对应列
            if(pt.table.find(x)==pt.table.end()||pt.table.find(x)->second.find(input_str_first)==pt.table.find(x)->second.end()){
//                exception3 代表预测分析表中找不到对应元素
                error("exception3 "+x);
            }
//            开始正式查表，y 为查到的产生式右部
            string y=pt.table.find(x)->second.find(input_str_first)->second;
            if(y=="error"){
//                exception4 代表查表查到了 error 项
                error("exception4 "+x);
                return at;
            }
            else{
                stack.pop_back();
                if(y!="ε"){
//                    逆向循环查到的产生式右部元素
                    for(auto iter=y.rbegin();iter!=y.rend();iter++){
//                        产生式右部第一个元素
                        string first;

                        if(*iter=='m'&&*(iter+1)=='u'&&*(iter+2)=='n'){
                            first="num";
                            iter+=2;
                        }
                        else{
                            first=string(1,*iter);
                        }
//                        入栈
                        stack.push_back(first);
                    }
//                    输出产生式 x->y
                    at.back().push_back(x+"->"+y);
                }
                else{
                    at.back().push_back(x+"-><epsilon>");
                }
            }
        }
        else{
//            exception5，栈顶既不是终结符也不是非终结符
            error("exception5 "+x);
            return at;
        }
    }
//    如果当栈中仅有一个元素时buf仅有一个$，表示字符串已接收
    if(input[ip]=='$'){
        cout<<"Accepted!"<<endl;

        vector<string> item;
        at.push_back(item);
        at.back().push_back("[\"$\"]");
        at.back().push_back("$");
    }
    else{
//        exception6 表示栈空了 buf 还没读完
        error("exception6 $");
    }
    return at;
}

void LL1_syntax_analyzer::print_predict_table(PREDICT_TABLE pt) {
    cout << "PREDICT_TABLE: " << endl;
    cout << "\t";
    for (auto iter: pt.table.begin()->second) {
        cout << iter.first << "\t\t";
    }
    cout << endl;
    for (auto & iter : pt.table) {
        cout << iter.first << "\t";
        for (auto iter2 = iter.second.begin(); iter2 != iter.second.end(); iter2++) {
            string output_str;
            if (iter2->second == "error") {
                output_str = "error";
            } else if (iter2->second == "ε") {
                output_str = iter.first + "-><epsilon>";
            } else {
                output_str = iter.first + "->" + iter2->second;
            }
            if (output_str.length() >= 8) {
                cout << output_str << "\t";
            } else {
                cout << output_str << "\t\t";
            }
        }
        cout << endl;
    }
}

void LL1_syntax_analyzer::print_analyze_table(ANALYZE_TABLE at) {
    cout<<"ANALYZE_TABLE:"<<endl;
    for (auto iter = at.begin(); iter != at.end(); iter++)
    {
        vector<string> analyze_table_item = *iter;
        for (auto iter2 = analyze_table_item.begin(); iter2 != analyze_table_item.end(); iter2++)
        {
            cout << *iter2;
            if (iter2 == analyze_table_item.begin())
            {
                for (int i = 0; i < 6 - iter2->size() / 8; i++)
                {
                    cout << "\t";
                }
            }
            else
            {
                for (int i = 0; i < 4 - iter2->size() / 8; i++)
                {
                    cout << "\t";
                }
            }
        }
        cout << endl;
    }
}

void LL1_syntax_analyzer::error(string e) {
    cout << e << endl;
}

void init(GRAMMAR_TABLE &g, FIRST_TABLE &fi, FOLLOW_TABLE &fo) {
    vector<string> V_E;
    V_E.push_back("TG");
    g.P.insert(pair<string, vector<string>>("E", V_E));

    vector<string> V_G;
    V_G.push_back("+TG");
    V_G.push_back("-TG");
    V_G.push_back("ε");
    g.P.insert(pair<string, vector<string>>("G", V_G));

    vector<string> V_U;
    V_U.push_back("*FU");
    V_U.push_back("/FU");
    V_U.push_back("ε");
    g.P.insert(pair<string, vector<string>>("U", V_U));

    vector<string> V_F;
    V_F.push_back("(E)");
    V_F.push_back("num");
    g.P.insert(pair<string, vector<string>>("F", V_F));

    vector<string> V_T;
    V_T.push_back("FU");
    g.P.insert(pair<string,vector<string>>("T",V_T));

    g.N.push_back("E");
    g.N.push_back("G");
    g.N.push_back("T");
    g.N.push_back("U");
    g.N.push_back("F");

    g.T.push_back("+");
    g.T.push_back("-");
    g.T.push_back("*");
    g.T.push_back("/");
    g.T.push_back("(");
    g.T.push_back(")");
    g.T.push_back("num");
    g.T.push_back("$");

    g.S = "E";


    vector<string> first_E;
    first_E.push_back("(");
    first_E.push_back("num");
    fi.insert(pair<string, vector<string>>("E", first_E));

    vector<string> first_G;
    first_G.push_back("+");
    first_G.push_back("-");
    first_G.push_back("ε");
    fi.insert(pair<string, vector<string>>("G", first_G));

    vector<string> first_T;
    first_T.push_back("(");
    first_T.push_back("num");
    fi.insert(pair<string, vector<string>>("T", first_T));

    vector<string> first_U;
    first_U.push_back("*");
    first_U.push_back("/");
    first_U.push_back("ε");
    fi.insert(pair<string, vector<string>>("U", first_U));

    vector<string> first_F;
    first_F.push_back("(");
    first_F.push_back("num");
    fi.insert(pair<string, vector<string>>("F", first_F));


    vector<string> follow_E;
    follow_E.push_back("$");
    follow_E.push_back(")");
    fo.insert(pair<string, vector<string>>("E", follow_E));

    vector<string> follow_G;
    follow_G.push_back("$");
    follow_G.push_back(")");
    fo.insert(pair<string, vector<string>>("G", follow_G));

    vector<string> follow_T;
    follow_T.push_back("+");
    follow_T.push_back("-");
    follow_T.push_back("$");
    follow_T.push_back(")");
    fo.insert(pair<string, vector<string>>("T", follow_T));

    vector<string> follow_U;
    follow_U.push_back("+");
    follow_U.push_back("-");
    follow_U.push_back("$");
    follow_U.push_back(")");
    fo.insert(pair<string, vector<string>>("U", follow_U));

    vector<string> follow_F;
    follow_F.push_back("*");
    follow_F.push_back("/");
    follow_F.push_back("+");
    follow_F.push_back("-");
    follow_F.push_back("$");
    follow_F.push_back(")");
    fo.insert(pair<string, vector<string>>("F", follow_F));
}
//把字符串里的数字都换成 num
string process(string str){
    string newStr;
    int isNum = 0;
    for (int i = 0; i < str.size(); i++)
    {
        if ((str[i] >= '0' && str[i] <= '9') || str[i] == '.')
        {
            if (!isNum)
            {
                isNum = 1;
                newStr += "num";
            }
            continue;
        }
        else
        {
            isNum = 0;
            newStr += str[i];
        }
    }
    return newStr;
}

int main(int argc,char *argv[]){

    LL1_syntax_analyzer sa;
    GRAMMAR_TABLE G;
    FIRST_TABLE first_table;
    FOLLOW_TABLE follow_table;
//    生成文法产生式、FI、FO
    init(G, first_table, follow_table);
//    生成预测分析表
    PREDICT_TABLE M = sa.create_predict_table(G, first_table, follow_table);
    sa.print_predict_table(M);
    cout << "Please input string:" << endl;
    string input_string;
    cin >> input_string;
    input_string = process(input_string);
    ANALYZE_TABLE at = sa.predict_analyze(input_string, M);
    sa.print_analyze_table(at);
    return 0;
}
```



### LR 分析程序源代码











































































































































































































































































































































