# 第四章 指令集

![image-20220407181707751](https://raw.githubusercontent.com/wangpaopao-lei/pic/master/image-20220407181707751.png)

## 指令系统的发展

1. 50 年代
   * ### 最基本的指令：定点加减、逻辑运算、数据传送、转移
   * 十几至几十条
2. 60 年代后期
   * 乘除运算、浮点运算、十进制运算、字符串处理
   * 一二百条
   * 寻址方式多样化
   * 出现系列计算机（软件方式相对稳定）
3. 70 年代末期：
   * 几百条（CISC（Complex） 复杂指令系统计算机）
   * 庞大的指令系统难以保证正确性，不易调试维护，造成硬件资源浪费
   * RISC（Reduced） 精简指令系统计算机出现

### 低级语言与高级语言

* 高级语言：语法与具体机器的指令系统无关
  * 编程难度低，可维护性高
  * 可移植性
* 低级语言：面向机器，和指令系统密切相关
  * 机器语言：二进制语言
  * 汇编语言：符号语言
  * 时空效率高

## 指令格式

1. 指令字：表示一条指令的机器字

2. 指令格式：指令用二进制代码表示的结构形式

3. 一条指令的==全部信息==必须明显或隐含的在指令中给出
   * 操作类型
   * 若干个源操作数的地址（内存或寄存器）
   * 目的操作数存放的地址（内存或寄存器）
   * 下一条指令的存放地址（内存单元）
   * ==操作码——地址码==

## 指令寻址方式

> 有效地址 EA（逻辑地址）：实际访问存储单元的地址
>
> 形式地址：指令中给出的地址码
>
> 寻址方式：形成有效地址的各种方法
>
> CPU 访存的目的：
>
> - 取指令（fetch）
> - 存取操作数（load/store）

指令寻址和数据寻址是交替进行的

### 顺序寻址

通常情况下，指令在内存中按顺序存放：指令的执行顺序就是指令的存放顺序

可以采用 PC 程序计数器自动加一的方式自动形成下一次的取指地址

### 跳跃（转移）寻址

下条指令的地址码不是由程序计数器给出，而是由本条指令给出

1. 转移指令的地址码字段包含下一条指令的地址
2. 执行跳跃指令时，将指令中给出的操作码送入 PC中
   * 下一次取指时仍从 PC 中指定的地址取指

## 操作数寻址方式

### 操作数的三个来源

1. 指令的地址码部分直接给出操作数
2. 存放在 CPU 内的数据寄存器中
3. 存放在内存的数据区（含 IO 寄存器）中
   1. 在指令中直接给操作数的==内存有效地址==
   2. 指令的地址字段给出==形式地址==
      - 指令执行时，形式地址依据某种方式变换为有效地址再存取操作数

### 隐含寻址

指令中的某个操作数或其地址隐含在某个通用寄存器或指定的内存单元中

### 立即寻址

指令的地址码字段指出的不是操作数的地址，而是操作数本身（立即数）
