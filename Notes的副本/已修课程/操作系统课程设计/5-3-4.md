# 使用 cgroup 实现限制访问 CPU 核数

## 实验内容

- 使用 cgroup 实现限制 CPU 核数
- 编写一个简单的 c 源程序，实现无限循环，使其占用某一进程（默认情况下会使得 CPU 资源消耗在 100%）
- 使用 cgexec 与 taskset 测试上述限制操作是否成功

## 实验设计原理及步骤

### 原理

1. cgroup：将任意进程进行分组化管理的 Linux 内核功能
   - 机制：以分组的形式对进程使用系统资源的行为进行管理和控制
   - 分组：又称进程组，包含多个进程。最初情况下，系统内的所有进程形成一个进程组（根进程组），根据系统对资源的需求，这个根进程组将被进一步细分为子进程组，子进程组内的进程是根进程组内进程的子集。
   - 如果某个进程组内的进程创建了子进程，那么该子进程默认与父进程处于同一进程组中。也就是说，cgroup对该进程组的资源控制同样作用于子进程。
2. cpuset 子系统：对多核 cpu，该子系统可以设置进程组只能在指定的核上运行
3. tmpfs 文件系统：临时文件系统，基于内存的文件系统。由于tmpfs完全存在于页面缓存和交换中，因此所有tmpfs页面将在 /proc/meminfo中显示为 “Shmem”，在free命令后中显示为“Shared”。
4. `mount`命令：cgroup 在 Linux 内核中以文件系统的形式存在，然而是只存在于内存中的虚拟文件系统，可以通过 mount 创建一个 cgroup 实例
5. `echo`命令：显示文字，将输入的字符串送往标准输出
6. `taskset`命令：根据线程 PID 查询或设置线程的 cpu 亲和性（与哪个 CPU 绑定）
7. `cgexec`命令：在指定的 cgroup 中执行任务

### 步骤

1. 挂载 tmpfs 格式的 cgroup 文件夹
2. 挂载 cpuset 子系统
3. 设置 cpu 核数
4. 编写一个死循环 while_long.c 源文件
5. 编译并在指定的 cpuset 子系统中运行 while_long 程序
6. 打开另一个终端，执行 top 命令，查看 while_long 的 pid
7. 执行` taskset -p [pid]`命令，查看 cpu 核数限制是否成功

## 实验结果及分析

### 准备部分

1. 创建 cgroup 文件夹
2. 使用 `mount` 命令实例化 tmpfs 格式的 cgroup 文件夹

![image-20230326171444664](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230326171444664.png)

3. 创建 cpuset 文件夹
4. 使用 `mount` 命令创建 cpuset 子系统

![image-20230326171500295](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230326171500295.png)

5. 运行`echo 0 > cpuset.mems`命令，设置内存 0 号节点
6. 运行`echo 0-2 > cpuset.cpus`命令，指定只使用 0,1,2 三个核
7. 运行 cat 命令查看是否成功

![image-20230326171620922](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230326171620922.png)

8. 编写一个 while_long.c 文件

### 测试部分

1. 打开一个终端，编译 while_long.c 文件
2. 使用`cgexec -g cpuset:mycpuset ./while_long`命令，指定在 cpuset 子系统中运行 while_long

![image-20230326174315085](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230326174315085.png)

3. 打开另一个终端，运行 top 命令

4. 找到 while_long 的 pid 为 29321

![image-20230326174256843](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230326174256843.png)

5. 执行`taskset -p 29321`，查看实验结果

![image-20230326174405055](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230326174405055.png)

实验成功！



## 程序代码

while_long.c

```C
#include<stdio.h>
#include<stdlib.h>

int main(int argc, char *argv[])
{
  	while(1){}
  	printf("Over");
  	exit(0);
}
```

```shell
mkdir cgroup
mount -t tmpfs tmpfs ./cgroup
cd cgroup/
mkdir cpuset
mount -t cgroup -o cpuset cpuset ./cpuset
cd cpuset/
mkdir mycpuset
cd mycpuset/
echo 0 > cpuset.mems
echo 0-2 > cpuset.cpus
```













