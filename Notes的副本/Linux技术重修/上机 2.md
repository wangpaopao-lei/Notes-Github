

# Linux 上机作业 ：遍历目录



<center>
  王磊 2020211538
</center>



## 1 实验要求

本实验要求学生使用 C 语言实现一个简化版的 Linux `ls` 命令，具体功能如下：

- 支持不同类型的处理对象：
  - 无对象时，列出当前目录下所有文件。
  - 文件对象时，列出指定文件。
  - 目录对象时，列出目录下所有文件。
- 实现自定义选项：
  - `r`：递归方式列出子目录。
  - `a`：包含隐藏文件（文件名以圆点开头的文件）。
  - `l`：限定文件大小的最小值（字节）。
  - `h`：限定文件大小的最大值（字节）。
  - `m`：限定文件的最近修改时间必须在1天内。
  - `--`：显式终止命令选项分析。

## 2 实验实现

### 2.1 `parse_options` 函数

**编写思路：**

- 使用 `getopt` 函数循环处理所有命令行参数。
- 根据每个参数设置 `Options` 结构体的相应字段。
- 对于需要参数值的选项，使用 `optarg` 来获取这些值。

**代码片段：**

```c
void parse_options(int argc, char *argv[], Options *opts) {
    int opt;
    while ((opt = getopt(argc, argv, "ral:h:m:--")) != -1) {
        switch (opt) {
            case 'r':
                opts->recursive = true;
                break;
            // 其他选项的处理...
            case 'm':
                opts->modified = true;
                opts->time_limit = time(NULL) - (atol(optarg) * 24 * 60 * 60);
                break;
            // 终止选项的处理...
        }
    }
}
```

### 2.2 `print_permissions` 函数

**编写思路：**

- 将文件模式转换为对应的权限表示。

**代码片段：**

```c
cCopy code
void print_permissions(mode_t mode) {
    char permissions[10];
    // ... (code to fill the permissions array)
    printf("%s ", permissions);
}
```



### 2.3 `list_directory` 函数

**编写思路：**

- 打开并读取目录流，遍历目录中的每个文件和子目录。
- 忽略隐藏文件，除非设置了 `a` 选项。
- 如果是子目录，并且设置了 `r` 选项，则递归调用此函数。
- 对于普通文件，调用 `list_file` 函数来处理。

**代码片段：**

```c
void list_directory(const char *dirname, Options opts, const char *prefix) {
    DIR *dir;
    struct dirent *entry;
    // ...
    while ((entry = readdir(dir)) != NULL) {
        if (!opts.all && is_hidden(entry->d_name)) {
            continue;
        }
        // ...
        if (S_ISDIR(statbuf.st_mode) && opts.recursive) {
            // 递归处理子目录
            // ...
        } else {
            list_file(path, &statbuf, opts);
        }
    }
    closedir(dir);
}
```

### 2.4 `list_file` 函数

**编写思路：**

- 检查文件是否符合由选项指定的大小限制。
- 如果设置了 `m` 选项，还需检查文件的修改时间。
- 打印符合条件的文件路径和名称。

**代码片段：**

```c
void list_file(const char *path, const struct stat *statbuf, Options opts) {
    if ((opts.min_size != -1 && statbuf->st_size < opts.min_size) ||
        (opts.max_size != -1 && statbuf->st_size > opts.max_size) ||
        (opts.modified && !is_within_time_limit(&statbuf->st_mtime, opts.time_limit))) {
        return; // 文件不符合条件，不打印
    }
    // 打印文件路径或名称
    printf("%s%s\n", path, opts.recursive ? "" : strrchr(path, '/') + 1);
}
```

## 3 运行效果

### `./list ..`

直接输出

![image-20231105160652423](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20231105160652423.png)

### `./list -r ..`

递归输出

![image-20231105161045376](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20231105161045376.png)



### `./list -a ..`

全部输出

![image-20231105160719298](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20231105160719298.png)

### `./list -l 500 -m 2 ..`

限制输出

![image-20231105161014615](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20231105161014615.png)



## 4 源代码目录

### CMakeList.txt



```Cmake
cmake_minimum_required(VERSION 3.21)
project(list C)

set(CMAKE_C_STANDARD 99)

add_executable(list main.c)

```

### List.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>
#include <time.h>
#include <pwd.h>
#include <grp.h>

typedef enum { false, true } bool;

typedef struct {
    bool recursive;
    bool all;
    long min_size;
    long max_size;
    time_t time_limit;
    bool end_of_options;
} Options;

void print_permissions(mode_t mode) {
    char permissions[10];
    permissions[0] = (S_ISDIR(mode)) ? 'd' : '-';
    permissions[1] = (mode & S_IRUSR) ? 'r' : '-';
    permissions[2] = (mode & S_IWUSR) ? 'w' : '-';
    permissions[3] = (mode & S_IXUSR) ? 'x' : '-';
    permissions[4] = (mode & S_IRGRP) ? 'r' : '-';
    permissions[5] = (mode & S_IWGRP) ? 'w' : '-';
    permissions[6] = (mode & S_IXGRP) ? 'x' : '-';
    permissions[7] = (mode & S_IROTH) ? 'r' : '-';
    permissions[8] = (mode & S_IWOTH) ? 'w' : '-';
    permissions[9] = (mode & S_IXOTH) ? 'x' : '-';
    printf("%s ", permissions);
}

void print_file_info(const char *file, struct stat *statbuf) {
    print_permissions(statbuf->st_mode);

    printf("%10ld ", statbuf->st_size);

    struct tm *tm = localtime(&statbuf->st_mtime);
    char date[20];
    strftime(date, sizeof(date), "%Y-%m-%d %H:%M", tm);
    printf("%s ", date);

    printf("%s\n", file);
}

void list_directory(const char *dirname, Options opts) {
    DIR *dir;
    struct dirent *entry;
    struct stat statbuf;
    char path[1024];
    int file_count = 0;

    if (!(dir = opendir(dirname))) {
        perror("opendir");
        return;
    }

    printf("%s:\n", dirname);
    while ((entry = readdir(dir)) != NULL) {
        if (!opts.all && entry->d_name[0] == '.') {
            continue;
        }

        snprintf(path, sizeof(path), "%s/%s", dirname, entry->d_name);
        if (lstat(path, &statbuf) == -1) {
            perror("lstat");
            continue;
        }

        if (S_ISDIR(statbuf.st_mode)) {
            if (opts.recursive && strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0) {
                list_directory(path, opts);
            }
        } else {
            print_file_info(entry->d_name, &statbuf);
            file_count++;
        }
    }
    closedir(dir);
    printf("%d files in total.\n\n", file_count);
}

void parse_options(int argc, char *argv[], Options *opts) {
    int opt;
    while ((opt = getopt(argc, argv, "ra")) != -1) {
        switch (opt) {
            case 'r':
                opts->recursive = true;
                break;
            case 'a':
                opts->all = true;
                break;
            default: /* '?' */
                fprintf(stderr, "Usage: %s [-ra] [directory...]\n", argv[0]);
                exit(EXIT_FAILURE);
        }
    }
}

int main(int argc, char *argv[]) {
    Options opts = {false, false, -1, -1, -1, false};

    parse_options(argc, argv, &opts);

    if (optind >= argc) {
        // 如果没有提供目录参数，则使用当前目录
        list_directory(".", opts);
    } else {
        // 遍历所有提供的目录参数
        for (int i = optind; i < argc; i++) {
            list_directory(argv[i], opts);
        }
    }

    return 0;
}

```

