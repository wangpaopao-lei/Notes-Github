![image-20220628125525737](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20220628125525737.png)

# 数据预处理

---

## `int`特征：

1. `income` 收入
   - 有一万多个缺失值
     - 均值填充
2. `age` 年龄
   - 有两万多个年龄为 0
     - 视作缺失值
     - 均值填充
3. `experience`职业经历
4. `currentjobyears`最近的工作的工作年份
5. `currenthouseyears`最近的房子的居住年份
6. `ID`——无关特征，删除

## `object`特征

1. `married`已婚
   - 已婚 1，未婚 0
2. `house_ownership`房子拥有权
   - onehot 编码
3.  `car_ownership`车拥有权
   - 无车 0，有车 1
4. `city`城市、`state`州、`profession`职业
   - 分类特征编码：`count_encoder`

# 建模

---

## 实例化





## 通过模型接口训练模型





## 通过模型接口提取需要的信息

predict_proba接口



## 调参

```python
start=time.time()
scorel = []
for i in range(0,200,10): # 迭代建立包含0-200棵决策树的RF模型进行对比
    rfc = RandomForestClassifier(n_estimators=i+1,n_jobs=-1,random_state=90)
    score = cross_val_score(rfc,X,Y,cv=10).mean()
    scorel.append(score)
print(max(scorel),(scorel.index(max(scorel))*10)+1)
end=time.time()
print('Running time: %s Seconds'%(end-start))
plt.figure(figsize=[20,5])
plt.plot(range(1,201,10),scorel)
plt.show()
```

计算 AUC 值

```python
from sklearn.metrics import roc_auc_score
y_score = clf.predict_proba(X_test)
print(f"AUC={roc_auc_score(y_test, y_score, average='micro')}")
```

![image-20220628173132197](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20220628173132197.png)

由默认的 0.89694 提升到了 0.89878

![image-20220628175911998](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20220628175911998.png)

提交答案，结果成绩只有 0.52



发现问题：

分割训练集进行测试时结果有很多 0，也有很多 0.4 以上的数据

使用测试集时几乎全部都是 0.1——0.4 之间的数据

![image-20220628231235333](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20220628231235333.png)

![image-20220628231243653](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20220628231243653.png)

我们分析训练集和测试集的数据分布情况，排除了数据分布不均的情况

![image-20220629083541667](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20220629083541667.png)