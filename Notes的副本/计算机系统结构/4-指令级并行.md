## contents

[toc]



# 指令级并行及其开发

![shadow-image-20230415181622359](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230415181622359.png)

![shadow-image-20230415181633656](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230415181633656.png)

![shadow-image-20230415181649899](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230415181649899.png)

## 概念

1. 流水线处理机的实际 CPI
2. 开发 ILP 的方法可以分为两大类
   - 基于硬件的动态开发方法
   - 基于软件的静态开发方法
3. 基本程序块（Basic Block）
   - 一串连续的代码除了入口和出口以外没有其他的分支指令和转入点
   - 基本程序块能开发的并行性有限
   - 为了明显提高性能，必须跨越多个基本程序块开发 ILP

4. 循环级并行：是一个循环冲不同循环体并行执行
   - 开发循环的不同迭代之间存在的并行性
   - 是指令级并行研究的重点之一
5. 最基本的开发循环级并行的技术
   - 循环展开
   - 采用向量指令和向量数据表示



## 相关与指令级并行

- 开发指令级并行需要解决的具体问题——相关与流水线冲突

- 两类解决方案：

  1. 保持相关，但避免发生冲突——>指令调度

  2. 通过代码变换，消除相关

- 程序顺序：由原来程序确定的在完全串行方式下指令的执行顺序

- 控制相关并不是一个必须严格保持的关键属性

- 对于正确执行的程序来说，必须保持的最关键两个属性：

  - ==保持异常行为==：无论怎么改变指令执行顺序，都不能改变程序中异常的发生情况
  - ==数据流==：数据值从其产生者指令到其消费者指令的实际流动





## 指令动态调度

- 静态调度
  - 依靠编译器对代码进行静态调度
- 动态调度
  - 在程序执行过程中，依靠专门硬件对代码进行调度，减少==数据相关导致的停顿==
  - **优点**：
    - 能够处理一些编译时情况不明的相关
    - 能够使本来面向某一流水线优化编译的代码在其他流水线上能高效执行
  - 以硬件复杂性显著增加为代价

### 基本思想

1. 经典（顺序）流水线最大的局限性：没有相关的指令也会受阻
   - ![shadow-image-20230415201207630](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230415201207630.png)
   - 一条指令受阻，后面的指令都停顿
   - 因为 ID（译码）阶段，会检测结构和数据冲突
   - 为了让 SUB.D 能够继续执行，必须把指令流出的工作拆分为两步
     - 检测结构冲突
     - 等待数据冲突消失
   - *只要检测到没有结构冲突，就可以让指令流出，并且流出后的指令一旦操作数就绪既可以立即执行*

2. 为了能==乱序执行==，将五段流水线的 ID 阶段再分为两个阶段
   1. 流出（Issue，IS）：译码，检测是否存在结构冲突
   2. 读操作数（Read Operands，RO）：等待数据冲突消失，然后读操作数
      - 结果就是：按序流出，乱序执行
3. **引入指令缓冲区**，直到冲突消除
4. 部署更多的执行部件，使多条指令能同时执行或访存
5. 动态调度流水线支持多条指令同时处于执行当中
   - 要求：
     - 多个功能部件
     - 功能部件流水化
   - *假设具有多个功能部件*
6. 复杂的异常处理：指令乱序带来的==最大问题==是异常处理比较复杂
   - 动态调度的处理机要保持正确的异常行为
   - 即使保持了正确的异常行为，动态调度处理机仍可能发生不精确异常
     - ==精确异常==：如果发生异常时，处理机的现场跟严格按程序顺序执行时指令 i 的现场相同
     - ==不精确异常==：不同
   - 发生不精确异常的原因：发生异常时
     1. 流水线可能已经执行完按程序顺序是位于指令 i 后的指令
     2. 流水线可能还没完成按程序顺序是 i 之前的指令

### 记分牌调度算法 scoreboard

#### 基本思想

“记分牌”硬件中维护三张表：

1. 指令执行状态
2. 寄存器状态
3. 数据相关关系

**目标：**在没有结构冲突时，尽可能早地执行没有数据冲突的指令，实现每个时钟周期执行一条指令。

##### 四段指令执行

每条指令的执行过程分为四段（主要考虑浮点操作）

1. **流出**：如果当前流出指令所需的功能部件空闲，所有其他正在执行的指令的目的寄存器与该指令不同，就流出该指令，修改记分牌记录表。==解决了 WAW 冲突==
2. **读操作数**：记分牌监测源操作数的可用性，如果数据可用，就去除操作数并开始执行。==解决了 RAW 冲突，并导致指令可能乱序开始执行==
3. **执行**：取到数后，开始执行。产出结果后通知记分牌已经完成。
4. **写结果**：记分牌一旦知道已完成执行，就检测是否存在 WAR 冲突，如果不存在或原有的 WAR 已消失，就通知功能部件把结果写入目的寄存器，并释放该指令的资源。
   - 如果检测到 WAR 冲突，就不允许写结果，发生在以下情况
     - 前面的某条指令还没有读（*其中某个源操作数寄存器与本指令的目的寄存器相同*）
     - ==记分牌必须等待，直到该冲突消失==

##### 记分牌记录的信息

1. **指令状态表**：记录正在执行的指令已经进入哪一阶段
2. **功能部件状态表**：每个功能部件有一项，记录功能部件的状态，由 9 个字段组成
   1. Busy：是否忙
   2. Op：正在执行或将要执行的操作
   3. Fi：目的寄存器编号，Fj、Fk 源寄存器编号
   4. Qj、Qk：指出向源寄存器 Fj、Fk 写数据的功能部件
   5. Rj、Rk：标志位，表明源寄存器的操作数是否就绪且还未被取走
3. **结果寄存器状态表Result**：每个寄存器在该表中有一项，用于指出哪个功能部件将把结果写入该寄存器

#### 举例

![shadow-image-20230509181202191](https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230509181202191.png)



#### 具体算法

##### 约定：

1. FU：当前指令要用到的功能部件
2. D：目的寄存器
3. S1、S2：源操作数寄存器
4. Op：要进行的操作
5. Fj[FU]：功能部件的 Fj 字段
6. Result[D]：结果寄存器状态表中与寄存器 D 对应的内容，其中存放的是将把结果写入寄存器 D 的功能部件的名称

##### 1 指令流出

- 进入条件：
  - Not Busy[FU] & not Result[D] //功能部件空闲且没有WAW 冲突
- 记分牌内容修改：
  - Busy[FU]←yes 		//把当前指令相关信息填入功能部件状态表
  - Op[FU]←Op  //记录操作码
  - Fi[FU]←D  //记录目的寄存器编号
  - Fj[FU]←S1  //记录第一个源寄存器编号
  - Fk[FU]←S2
  - Qj[FU]←Result[S1]  //记录产生第一个源操作数的部件
  - Qk[FU]←Result[S2]
  - Rj[FU]←not Qj[FU]  //置第一个源操作数是否可用的标志
    - 如果Qj[FU]为 no，标识没有操作部件要写 S1，数据可用，置 Rj[FU] 为 no
  - Rk[FU]←not Qk[FU]
  - Result[D]←FU  //功能部件FU 将结果写入 D

##### 2 读操作数

- 进入条件：
  - Rj[FU] & Rk[FU]  //两个操作数都已就绪
- 记分牌内容修改
  - Rj[FU]←no  // 读走第一 个源操作数
  - Rk[FU]←no
  - Qj[FU]←0  //不再等待其他计算结果作为源操作数
  - Qk[FU]←0

##### 3 执行

- 结束条件：
  - 功能部件操作结束

##### 4 写结果

- 进入条件：
  - <img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230510142010383.png" alt="image-20230510142010383" style="zoom:33%;" />
- 记分牌内容修改：
  - <img src="https://wangleidetuchuang.oss-cn-beijing.aliyuncs.com/img/image-20230510142051564.png" alt="image-20230510142051564" style="zoom:33%;" />

#### 记分牌局限性

1. 代码可开发的并行性
2. 记分牌容量（流水线能同时容纳的指令数量称之为指令窗口）
3. 功能部件的数目和种类（结构冲突的严重程度）
4. 名相关（反相关和输出相关→WAR 和 WAW 冲突）



### Tomasulo 算法

#### 基本思想

记录和检测指令相关，操作数一旦就绪就立即执行。

通过寄存器换名来消除 WAR 冲突和 WAW 冲突



==保留站==：每个保留站中保存一条已经流出并的等待本功能部件的指令

包括：操作码、操作数以及用于检测和解决冲突的信息

- 在一条指令后流出到保留站的时候，如果该指令的源操作数已经在寄存器中就绪，则将其取到该保留站中
- 如果该操作胡还没有计算出来，则在保留站汇总记录将产生这个操作数的保留站的标识



寄存器换名通过保留站和流出逻辑共同完成

- 指令流出时，如果操作数还没有计算出来，则将该指令中相应的寄存器号换名为产生这个操作数的保留站的标识
- 指令流出到保留站后，其操作数寄存器号会哦在换成了数据本身（如果数据已就绪），或者换成了保留站标识，不再与寄存器有关



特点：

1. 冲突检测和指令执行控制是分布的：每个功能部件保留站中的信息决定了什么时候指令可以在该功能部件开始执行
2. 计算结果通过 CDB 直接从产生它的保留站传送到所有需要它的功能部件，不用经过寄存器



##### 三段指令执行



##### 保留站保存的信息

1. Op：要对源操作数进行的操作
2. Qj, Qk：将产生源操作数的保留站号（等于 0 表示已就绪或不需要）
3. Vj, Vk：源操作数的值
4. Busy：本保留站或缓冲单元忙
5. A：仅 load 和 store 缓冲器有该字段，开始时存放指令中的立即数字段，地址计算后存放有效地址



Qi 寄存器状态表：每个寄存器在该表中有对应的一项，用于存放将把结果写入该寄存器的保留站号，为 0 代表当前没有正在执行的指令要写入该寄存器（内容就绪）

## 动态分支预测技术

根据分支指令过去的表现来预测其将来的行为



有效性取决于：

1. 预测的准确性
2. 正确和不正确两种情况下的分支开销
3. 决定分支开销的因素
   1. 流水线结构
   2. 预测的方法
   3. 预测错误时的恢复策略



### 分支历史表 BHT





## 多指令流出技术





