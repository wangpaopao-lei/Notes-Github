## 老和尚小和尚问题

### 分析问题

1. 水缸：生产者-消费者问题，同步问题
   1. 水缸非空才能取水
   2. 水缸非满才能倒水
   3. 水缸需要被互斥访问
2. 水井：取水，互斥访问
3. 水桶：临界资源，互斥访问

### 设置信号量

1. 水缸empty，表示空闲水缸数量，初始值为 10
2. 水缸 full，表示非空水缸数量，初始值为 0
3. 水缸 mutex，表示水缸需要互斥访问，初始值为 1
4. 水桶 tong，临界资源信号量用于互斥访问，初始值为 3
5. 水井 jing，需要互斥访问，初始值为 1

### 具体算法描述

```pseudocode
semaphore empty=10;
semaphore full = 0;
semaphore mutex = 1;
semaphore tong = 3;
semaphore jing = 1;

void xiaoheshang(){
  P(tong);	//访问水桶资源，若无空闲水桶，阻塞
  P(jing);	//访问水井
  qushui;
  V(jing);	//释放水井
  P(mutex);	//互斥访问水缸
 	P(empty);	//水缸内水不为难时可以倒水
  daoshui;
  V(mutex);	//释放水缸
  V(full);	//水缸内多了一桶水，full 加一
  V(tong);	//归还水桶
}

void laoheshang(){
	P(full);	//水缸内水不为空时可以取水
	P(tong);	//访问水桶资源
	P(mutex);	//互斥访问水缸
	heshui;		//
	V(mutex);	//释放水缸
	V(tong);	//归还水桶
	V(empty);	//水缸内少一桶水
}
```



## 多类型读者-写者问题

### 问题分析

1. 读者 A 可以同时访问，但与读者 B 和 C 互斥访问
2. 读者 B 可以同时访问，但与读者 A 和 C 互斥访问
3. 读者 C 只能互斥访问

### 信号量设置

1. 读者数 countA，表示当前正在访问的读者数，初始值为 0
2. A 类读者 rA，表示 A 类读者的访问权限，初始值为 1
3. B 类读者 rB，表示 B 类读者的访问权限，初始值为 1
4. 互斥变量 mutex，实现对 count 的互斥访问，初始值为 1

### 算法具体描述

```pseudocode
int count=0;
semaphore rA=1;
semaphore rB=1;
semaphore mutex=1;

writerC(){
	while(1){
		P(rA);
		P(rB);
		write;
		V(rA);
		V(rB);
	}
}

readerA(){
	while(1){
		P(mutex);
		if(count==0)
			P(rA);			
		count++;
		V(mutex);
		read;
		P(mutex);
		count--;
		if(count==0)
			V(rB)
		V(mutex);
	}
}

readerB(){
	while(1){
		P(mutex);
		if(count==0)
			P(rB);			
		count++;
		V(mutex);
		read;
		P(mutex);
		count--;
		if(count==0)
			V(rA)
		V(mutex);
	}
}
```



## 牙科门诊

### 问题分析

1. 没有候诊状态患者，医生去休息
2. 有候诊状态患者，医生工作
3. 患者到达，有号，候诊
4. 患者到达，没号，离开
5. 医生和患者状态需要互斥修改

### 信号量设置

1. 互斥变量1 mutex1，用于互斥访问 DState，初始值为 1
2. 互斥变量2 mutex2，用于互斥访问 PState，初始值为 1
3. 医生状态向量 DState[3]，休息为0，工作为 1
4. 患者就诊状态向量 PState[20]，剩余为-1，候诊为0，就医为 1
5. 信号量 den，表示空闲牙医数量，初始为 0
6. 信号量 pat，表示等待的患者数量，初始为 0
7. 控制变量 i，表示当前理发师
8. 控制变量 j，表示当前病人排号



### 具体算法描述

```pseudocode
semaphore mutex1=1;
semaphore mutex2=1;
semaphore den=0;
semaphore pat=0;
int i=0;
int j=0;
int DState[3]=1;
int PState[20]=-1;



void dentist(){
	while(1){
		P(pat);						//没有患者时阻塞
		P(mutex1);				//互斥修改 DState
		for(i=0;i<3;i++){
			if(DState[i]==0)//
			{
				DState[i]=1;	//让 i 号牙医出诊
				break;				
			}
		}
		V(mutex1);				
    switch(i){				//判断出诊的是几号牙医
    	case 0:{
    		1 号牙医就诊;
    		V(den);
    	}
    	case 1:{
    		1 号牙医就诊;
    		V(den);
    	}
    	case 2:{
    		2号牙医就诊;
    		V(den);
    	}
    }
    P(mutex1);
    DState[i]=0;			//让 i 号牙医休息
    V(mutex1);
	}
}

void patient(){
	while(1){
		P(mutex2);			//互斥修改 PState
		if(j<20)				//有号时进入等待就诊程序
		{
			PState[j]=0;	//修改状态为等待
			j++;	
			V(pat);				//患者数量增加
			P(den);				//若无休息牙医，阻塞（等待）
			治疗;
			PState[j]=1;	//患者进入就医状态
		}
		V(mutex2);
	}
}
```

